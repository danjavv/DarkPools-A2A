\section{Comparison}

This section describes how to compare two boolean integer shares.
There are two types of comparison supported:
\begin{itemize}
	\item{\bf Equality Comparisons} test whether two stored boolean integers are equal.
	\item{\bf Inequality Comparisons} tests whether a specified relation in $\{<, \leq, \geq, >\}$ holds between two stored boolean integers.
\end{itemize}

\subsection{Equality Comparison} 

To determine if two boolean integer shares are equal, the inputs are first converted into bit vector shares. Then, a bitwise XOR operation is performed on corresponding bits. If $x = y$, all bits in the resulting XOR vector should be false. To check if any bit is true, an OR operation is applied across the XOR result, reducing it to a single bit. The inverse of this bit is then returned as the output. 

\begin{protocol}[Equality Comparison]
	$\CompareEqual{\bint{x}}{\bint{y}}$:\\
	\indent $\bint{x'}, \bint{y'}=$ EqualizeLength$(\bint{x}, \bint{y})$ \\
	\indent $\bitvec{X}$ = B2BitArr($\bint{x'}$)\\
	\indent $\bitvec{Y}$ = B2BitArr($\bint{y'}$)\\
	\indent $\bitvec{T} = map(\oplus, \bitvec{X}, \bitvec{Y})$ \\	
	\indent $\bit{o} = reduce($OR$, \bitvec{T})$ \\
	\indent return NOT$(\bit{o})$ \\
\end{protocol}

This method can be extended to compare any boolean vector shares of equal length.


\subsection{Greater Than or Equal To Comparison} 
To compare whether $\bint{x} \geq \bint{y}$, we identify the first position where the two inputs differ and check whether the corresponding bit in $\bint{y}$ is set. If this bit is true, the output is false; otherwise, the output is true. To implement this comparison in a secret-shared manner while minimizing round complexity, we adopt a recursive approach.

The comparison begins by converting the inputs into bit-vector shares and recursively dividing them into two halves allowing parallel execution. Each recursion produces two secret-shared outputs:one indicating the comparison result within the input range ($subres$),  and the other signaling whether any corresponding bits differ within that range ($subdiff$). The base case occurs when the length of the inputs is $1$, at which point the comparison is performed directly. In the recursive process, precedence is given to the right half (lower indices), ensuring that if a decision is made by any bit in the later part of the array, the left half is disregarded.

\begin{protocol}[Greater Than or Equal To Comparison]	
	$\CompareGreaterThanOrEqualTo{\bint{x}}{\bint{y}}$:\\
	\indent $\bint{x'}, \bint{y'}=$ EqualizeLength$(\bint{x}, \bint{y})$ \\
	\indent $\bitvec{X}$ = B2BitArr($\bint{x'}$)\\
	\indent $\bitvec{Y}$ = B2BitArr($\bint{y'}$)\\
	\indent $l = $len($\bitvec{X}$) \\
	\indent $\bit{subres}, \bit{diff} = $CompGERec$(\bitvec{X}, \bitvec{Y}, 0, l-1)$ \\
	\indent return $\bit{op}$ \\
	
	\noindent
	$\CompGERec{\bitvec{X}}{\bitvec{Y}}{lo}{hi}$:\\
	\indent if $lo == hi$: \\
	\indent \indent $\bit{a} = \bitvec{X_{lo}} \oplus \bitvec{Y_{lo}}$ \\
	\indent \indent $\bit{t} = $ NOT$(\bitvec{Y_{lo}} \wedge \bit{a})$ \\
	\indent \indent return $\bit{t}, \bit{a}$ \\
	\indent $m = \lfloor lo + (hi - lo)/2\rfloor$ \\
	\indent $\bit{subres_l}, \bit{diff_l} =$ CompGERec$(\bitvec{X}, \bitvec{Y}, lo, m)$ \\
	\indent $\bit{subres_h}, \bit{diff_h} =$ CompGERec$(\bitvec{X}, \bitvec{Y}, m + 1, hi)$\footnote{These two instances of CompGERec are to be instantiated in parallel recursively.} \\
	\indent $\bit{subres} = $ IfThenElse$(\bit{diff_h}, \bit{subres_h}, \bit{subres_l})$ \\
	\indent $\bit{diff} = \bit{diff_l} \vee \bit{diff_h}$ \\
	\indent return $\bit{subres}, \bit{diff}$
	
\end{protocol}

\subsection{Extending to other comparisons}

\paragraph{\bf Less Than or Equal To ($x \leq y$):} To compute $x \leq y$, swap the roles of $x$ and $y$ in the greater than or equal to protocol. Specifically, execute $\CompareGreaterThanOrEqualTo{\bint{y}}{\bint{x}}$.

\paragraph{\bf Less Than ($x < y$):}  To compute $x < y$, compute $x \geq y$ and take its inverse.

\begin{protocol}[Less Than Comparison]	
	$\CompareLessThan{\bint{x}}{\bint{y}}$:\\
	\indent $\bit{op} =$ CompareGreaterThanOrEqual$($\bint{x}, \bint{y}$)$ \\
	\indent return NOT$(\bit{op})$
\end{protocol}

\paragraph{\bf Greater Than ($x > y$):} To compute $x > y$, swap the roles of $x$ and $y$ in the less than protocol. Specifically, execute $\CompareLessThan{\bint{y}}{\bint{x}}$.
