\section{ABB support: types and operations}

\begin{table}
\begin{tabular}{|l|l|l|l|}
	\hline
	Data Type 	& Sharing Type		& ABB Name	& Notation \\ \hline
	$\Z_2$ (bit) 	& Boolean RSS		& BoolBit  	& $[x]^{Bb}$ \\ \hline
	$\Ztwol$ (uint) & Bit-wise Boolean RSS	& BoolInt	& $[x]^{Bi}$ \\ \hline
	$\Ztwol$ (uint) & RSS over \Ztwol	& ArithInt	& $\aint{x}$ \\ \hline
	$\GFtwol$ 	& RSS over \GFtwol	& Galois	& $[x]^{G}$ \\ \hline
	$\Zp$ (mod p)	& RSS over \Zp		& ArithModp	& $\modarith{x}$ \\ \hline
	EC point 	& Arithmetic Pair	& ECArith	& $[x]^{Ae}$ \\ \hline
	EC point 	& RSS over Curve	& ECPoint 	& $[x]^{\G e}$ \\ \hline
	Fixed point 	& Custom		& FixedPoint	& $[x]^{F}$ \\ \hline
	Decimal		& Custom		& Dec	 	& $[x]^{D}$ \\ \hline 
\end{tabular}
	\caption{List of supported ABBs (type-sharing combinations) with Notation}
	\label{tab:abb_list}
\end{table}

Our most basic ABB is the BoolBit ABB, which only allows the storage of individual bits.
Apart from inputting and outputting, it also supports the basic 
bit operations of XOR, AND, OR, and NOT. 
It supports a 2-input multiplixer gate (equivalent to an IfThenElse statement).
It also supports the generation of a new random bit within the ABB (unknown to all parties).
Finally, it supports copying of variables stored in the ABB.

This is used to construct the more complex BoolInt ABB which supports the storage
of non-negative integers. 
For each variable stored in the BoolInt ABB, the bit-length, $l$, is well-defined
(although is often implicit).
Apart from the natural bit-wise extensions of the operations of BitABB, 
this further supports integer operations such as addition and subtraction (modulo $2^l$),
comparison operations (e.g. $<$, $=$) and bit-shifts.

Addition and subtraction of integers in BoolInt ABB is expensive.
We therefore implement ArithInt ABB, which uses a fundamentally different sharing
mechanism to store non-negative integers (of some defined bit-length $l$).
Rather than secret-sharing each bit, the ArithInt ABB secret-shares each item
using Replicated Secret Sharing over $\Ztwol$. 
This allows addition and subtraction to be performed using only local operations.
The same applies for multiplication by public constants,
and addition/subtraction of constants.
The ArithInt ABB also supports conversion between variables stored in the
ArithInt and BoolInt ABBs.

We also have variables which represent members of the Galois Fields $\GFtwol$
(with an irreducible polynomial defined for each $l$).
Unlike $\Ztwol$, $\GFtwol$ is a field, but still holds $2^l$ elements.
This allows the usage of field properties (such as each item having a multiplicative inverse).
Addition in $\GFtwol$ is supported: it is simply bitwise XOR.
This ABB supports multiplication of an ABB-stored value by a public constant
as well as multiplication of ABB-stored values in which the adversary
can introduce an error.
(These protocols are useful for MACs and shuffle protocols.)

We implement an ABB for arithmetic modulo primes, which we implement with the
ArithModp ABB.
This is useful for many applications, for instance to store points on an elliptic curve.
We use a RSS-based sharing over arithmetic modulo p, similar to the ArithInt type.

We futher support ABBs for Elliptic Curve points
(one representing data as a pair of ArithModp points, 
the other using replicated shares over the Elliptic Curve group),
an ABB for Fixed point variables (FixedPointABB), represented as $[x]^F$
and an ABB for Decimal values (DecimalABB) represented as $[x]^D$.

