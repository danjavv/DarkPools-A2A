\section{Comparison}
\label{sec:comparison}

\subsection{Compare equal}
\label{sec:compare_eq}

This function takes two $l$-bit $\BinaryStringShare$ values as input and outputs $[\true]^B$ if the two values are equal, and $[\false]^B$ otherwise. The protocol operates as follows:
\begin{enumerate}
    \item Each party computes the XOR of the corresponding bits in the two $\BinaryStringShare$ inputs, resulting in an intermediate $\BinaryStringShare$ called $\mathsf{temp}$. The $\mathsf{temp}$ share will have a $\true$ bit wherever the corresponding bits of the inputs differ.

    \item To determine whether the inputs differ in any bit, the parties iteratively perform a logical OR across all $l$ bits of $\mathsf{temp}$. This produces a single binary share that is $\true$ if there is at least one bit of difference and $\false$ otherwise.

    \item The parties locally invert the result of the OR operation. If all bits of the inputs are identical, the output will be $[\true]^B$, indicating equality. Otherwise, the output will be $[\false]^B$.
\end{enumerate}

\begin{protocol}[CompareEqual$({[\vec{A}]^B}, {[\vec{B}]^B})$]
	${[\vec{temp}]^B} =$ XOR$({[\vec{A}]^B}, {[\vec{B}]^B})$\\
	$[outInv]^B = $ DefaultBinaryShare$(\false)$ \\
	for $i = 0, \ldots, l - 1$:\\
	\indent $[outInv]^B = ([outInv]^B \cdot [\vec{temp}_i]^B) \oplus ([outInv]^B \oplus [\vec{temp}_i]^B)$\\
	return Inverse$([outInv]^B)$
\end{protocol}

\subsection{Compare greater than}
\label{sec:compare_ge}

This function takes two integers represented by $l$-bit $\BinaryStringShare$ values (say $\vec{A}$ and $\vec{B}$) as input, and outputs $[\true]^B$ if the first input is greater or equal to the second input and $[\false]^B$ otherwise. The protocol operates as follows:

\begin{enumerate}
    \item Each party computes the XOR of the corresponding bits in the two $\BinaryStringShare$ inputs, resulting in an intermediate $\BinaryStringShare$ called $xor$. The $xor$ share will have a $\true$ bit wherever the corresponding bits of the inputs differ.
    \item Two binary shares are initialized:
    \begin{itemize}
        \item $[current]^B$: Represents whether the first input is greater than or equal to the second input. Initialized to $\true$.
        \item $[decision]^B$: Tracks whether the "greater-than-or-equal" relationship has been conclusively determined. Initialized to $\false$.
    \end{itemize} 
    \item The parties iterate over the bits of $xor$ and the second input ($\vec{B}$), starting from the most significant bit (MSB) and proceeding to the least significant bit (LSB). The key logic is:
    \begin{itemize}
        \item If the first differing bit is such that the corresponding bit in $\vec{A}$ is $\false$ and in $\vec{B}$ is $\true$, $current$ is set to $\false$. Otherwise, $current$ remains $\true$.
        \item Once the $[decision]^B$ becomes $[\true]^B$, indicating the relationship has been determined, $[current]^B$ is fixed and no longer changes.
    \end{itemize}
    \item The $current$ share is updated based on the current bit of $xor$ and $\vec{B}$. If $decision$ is $[\false]^B$, $current$ can change. If $decision$ is $\true$, $current$ remains unchanged. The $decision$ share is updated to $\true$ the first time a difference is detected (when a bit of $xor$ is $\true$).
\end{enumerate}

\begin{protocol}[CompareGreaterThanOrEqualTo$({[\vec{A}]^B}, {[\vec{B}]^B})$]
	${[\vec{xor}]^B} =$ XOR$({[\vec{A}]^B}, {[\vec{B}]^B})$\\
	$[current]^B = $ DefaultBinaryShare$(\true)$ \\
	$[decision]^B = $ DefaultBinaryShare$(\false)$ \\
	for $i = l - 1, \ldots, 0$:\\
	\indent $[temp]^B = \text{Inverse}([\vec{xor}_i]^B \cdot [\vec{B}_i]^B)$\\
        \indent $[current]^B = ([temp]^B \cdot \text{Inverse}([decision]^B)) \oplus ([current]^B \cdot [decision]^B)$\\
	\indent $[decision]^B = ([decision]^B \cdot [\vec{xor}_i]^B) \oplus ([decision]^B \oplus [\vec{xor}_i]^B)$\\
	return $[current]^B$
\end{protocol}

\subsection{Compare greater than EC}
\label{sec:compare_ge_ec}

This function is identical to Protocol \ref{sec:compare_ge} in both its logic and operation. The only difference is that the input length is longer compared to protocol from Section \ref{sec:compare_ge}. For the sake of brevity, the detailed explanation and protocol steps are not repeated here.

\subsection{Compare less than or equal to}
\label{sec:compare_le}

This function takes two integers represented by $l$-bit $\BinaryStringShare$ values (say $\vec{A}$ and $\vec{B}$) as input, and outputs $[\true]^B$ if the first input is greater or equal to the second input and $[\false]^B$ otherwise. The protocol builds on the intuition of combining the results of Protocols \ref{sec:compare_eq} and \ref{sec:compare_ge}. By determining whether the two numbers are equal and whether the first is greater than or equal to the second, the less-than-or-equal relationship can be easily derived.


\begin{protocol}[CompareLessThanOrEqualTo$({[\vec{A}]^B}, {[\vec{B}]^B})$]
	$[eq]^B =$ CompareEqual$({[\vec{A}]^B}, {[\vec{B}]^B})$\\
	$[ge]^B =$ CompareGreaterThanOrEqualTo$({[\vec{A}]^B}, {[\vec{B}]^B})$\\
	$[inv\_ge]^B =$ Inverse$([ge]^B)$\\
	$[output]^B = (inv\_ge \cdot eq) \oplus (inv\_ge \oplus eq)$\\ 
	return $[output]^B$
\end{protocol}