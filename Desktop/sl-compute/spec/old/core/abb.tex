\section{Arithmetic Black Box}
\label{sec:abb}

This section describes the functionality provided by the core computing framework.
This abstracts away secret-sharing; variables that have been secret-shared are viewed
as stored by a functionality called the Arithemtic Black Box (ABB) \cite{C:DamNie07}.
The ABB can also perform basic operations on stored secret variables:
addition and multiplication, bitwise operations (AND, XOR, bit truncation), 
comparison operations (e.g. =, <) and conditionals (if/then).
The ABB additionally allows individual parties to input (private) variables,
and also allows stored secret variables to be revealed to individual parties or to all parties.
The ABB functionality is presented in Figure \ref{functy:ABB} below.

We use the notation $[x]$ to indicate that a variable, with public identifier $x$,
is stored in the ABB.
When an operation stores a new variable in the ABB, 
a temporary identifier is created for it.
This temporary identifier can either be used to assign a new public identifier to
the variable (e.g. $[z] = \Add{[x]}{[y]}$)
or it can be used to reference the variable as an input for another computation
(e.g. the addition in $\MultConst{\Add{[x]}{[y]}}{c}$).
Either way we say that the operation \emph{returns} the result,
where the result is written insed $[\cdot]$-notation.
For instance ``return $[x+y]$'' means store $x + y$ in the ABB,
create a temporary identifier to this new variable and return the identifier.

The functions $\OutputSinglex$ and $\OutputToAll{}$ do \emph{not} return identifiers
to ABB-stored variables, but return the variables themselves,
either to a single party (for $\OutputSinglex$) or to all parties (for $\OutputToAll{}$).
While the identifier to the variable may be either public or private,
the variable itself is known only by the parties who receive it.

To allow each operation to be performed using protocols efficient in its setting
the ABB implementation will use a combination of Arithmetic, Boolean and Yao sharings.
The type of sharing used to represent a variable is represented using a super-script,
that is $[x]^A$, $[x]^B$ and $[x]^Y$ respectively.
Unless otherwise indicated, all variables are $l$-bit integers, for some fixed $l$.
Exceptions include the outputs of Random, Concatenation and Slicing,
where the bit-length of the output depends on the parameters,
and of Compare, which returns a single bit.
To preserve readability, the bit-lengths are not stated explicitly
in the variable name or notation.

\begin{functionality}[Arithmetic Black Box (ABB)]\label{functy:ABB}
	\Input{x}{P_i}: \\
		\indent $P_i$ provides a private variable $x$. \\
		\indent $x$ is stored as $[x]$ in the ABB. \\ \\ 
	\OutputSingle{[x]}{P_i}: \\
		\indent $P_i$ privately receives variable $x$ which was stored in the ABB. \\ \\
	\OutputToAll{[x]}: \\ 
		\indent All parties receive variable $x$ which was stored in the ABB. \\ \\
	\Add{[x]}{[y]}: Shorthand $[x] + [y]$. \\
		\indent Return $[x+y]$ \\ \\
	\AddConst{[x]}{c}: Shorthand $[x] + c$ (or $c + [x]$). \\
		\indent Return $[x+c]$ \\ \\
	\Sub{[x]}{[y]}: Shorthand $[x] - [y]$. \\
		\indent Return $[x - y]$ \\ \\
	\SubConst{[x]}{c}: Shorthand $[x] - c$. \\
		\indent Return $[x - c]$ \\ \\
	\Mult{[x]}{[y]}: Shorthand $[x] \cdot [y]$. \\
		\indent Return $[x \cdot y]$ \\ \\
	\MultConst{[x]}{c}: Shorthand $[x] \cdot c$ (or $c \cdot [x]$). \\
		\indent Return $[x \cdot c]$ \\ \\
	\MultWithError{[x]}{[y]}: \\
		\indent The adversary specifies an error term $\delta$.\\
		\indent Return $[ (x \cdot y) + \delta]$ \\ \\
	\Random{m}: \\
		\indent Let $r$ be chosen at random from $\{0, 1\}^m$.\\
		\indent Return $[r]$\\ \\
	\Concat{[x]}{[y]}: \\
		\indent Let $lx$ be the bit-length of $x$.
			Let $ly$ be the bit-length of $y$.\\
		\indent Set $z$ to be a $lx + ly$-bit value.\\
		\indent Set bits $1, \ldots, lx$ of $z$ to be $x$.\\
		\indent Set bits $lx+1, \ldots, lx+ly$ of $z$ to be $y$.\\
		\indent Return $[z]$\\ \\
	$\Slice{[x]}{a}{b}$: Shorthand $[x_{a, \cdots, b}]$. \\
		\indent Assumes $1 \leq a \leq b \leq m$, where $m$ is the bit-length
		of $x$.\\
		\indent Create a $(b-a+1)$-bit number $z$,
			where the $i^{th}$ bit of $z$ is the $(i+a)^{th}$ bit of $x$;
			that is $z$ holds the bits of $x$ from $a$ to $b$ inclusive.\\
		\indent Return $[z]$\\ \\
	\Compare{rel}{[x]}{[y]}: Shorthand $[x]$ rel $[y]$.\\
		\indent rel $\in \{<, \leq, =, \neq, \geq, >\}$ is a (public) relation.\\
		\indent If $x$ rel $y$ is true, return $[1]$, else return $[0]$. \\ \\
	\IfThen{[b]}{[x]}{[y]}: \\
		\indent Assumes $b=0$ (false) or $b=1$ (true). \\
		\indent If $b = 1$ return $[x]$, otherwise return $[y]$. \\
\end{functionality}

In this document, we will consider the case where there are 3 parties,
at most 1 corruption, which is static and malicious.
The ABB can be implemented in this security setting using the following protocols.
The parties are identified as $P_0$, $P_1$ and $P_2$.
For subscript notations involving parties and shares,
there is implicit wrap-around modulo 3
(e.g. if $i=2$, $P_{i+1} = P_0$).
This implementation is based on \cite{EC:FLNW17}.

\begin{protocol}[ABB: Input, Output and Relabel]
	\InputB{x}{P_i}: \\
	\indent $P_i$ is in possession of private variable $x \in \{0, 1\}^t$. \\
	\indent $P_i$ selects $x_0, x_1$ at random from $\{0, 1\}^t$. \\
	\indent $P_i$ sets $x_2 = x \oplus x_0 \oplus x_1$.\\
	\indent $P_i$ sends $(x_{i-1}, x_i)$ to $P_{i-1}$ and
			$(x_{i+1}, x_{i-1})$ to $P_{i+1}$. \\
	\indent $P_i$ keeps $(x_i, x_{i+1})$ as its share.\\
	\indent $P_{i-1}$ sets the received $(x_{i-1}, x_i)$ as its share.\\
	\indent $P_{i+1}$ sets the received $(x_{i+1}, x_{i-1})$ as its share.\\
	\indent The label ``$[x]^B$'' is used by all parties to identify their shares. \\

	\noindent \OutputSingle{[x]}{P_i}: \\
	\indent Let $(x_{i-1}, x_i)$ be $P_{i-1}$'s share of $[x]^B$.
		$P_{i-1}$ sends $x_{i-1}$ to $P_i$.\\
	\indent Let $(x_{i+1}, x_{i-1})$ be $P_{i+1}$'s share of $[x]^B$.
		$P_{i+1}$ sends $x_{i-1}$ to $P_i$.\\
	\indent $P_i$ verifies that the two values of $x_{i-1}$ that it received
		from $P_{i-1}$ and $P_{i+1}$ are equal. \\
	\indent Let $(x_i, x_{i+1})$ be $P_i$'s share of $[x]^B$. 
		$P_i$ locally stores $x = x_0 \oplus x_1 \oplus x_2$. \\

	\noindent \OutputToAll{[x]}: \\
	\indent Call $\OutputSingle{[x]}{P_i}$, for all $i = 0,1,2$.\\

	\noindent $\Concat{[a]^B}{[b]^B}$: \\
	\indent $la = len([a]^B)$\\
	\indent $lb = len([b]^B)$\\
	\indent $[c_{1, \ldots, la}]^B = [a]^B$\\
	\indent $[c_{la+1, \ldots, la + lb}]^B = [b]^B$\\
	\indent return $[c]^B$ \\

	\noindent $\Slice{[c]^B}{from}{to}$ : \\
	\indent $[a] = [c_{from, \ldots, to}]$\\
	\indent return $[a]$\\
\end{protocol}


\begin{protocol}[ABB: Boolean Arithmetic]
	$\Add{[x]^B}{[y]^B}$: \\
	\indent	$P_i$ has $(x_i, x_{i+1})$ and $(y_i, y_{i+1})$ as
		shares of $[x]^B$ and $[y]^B$ respectively. \\
	\indent $P_i$ computes $z_i = x_i \oplus y_i$ and $z_{i+1} = x_{i+1} \oplus y_{i+1}$.\\
	\indent $P_i$ sets $(z_i, z_{i+1})$ as its shares of the result.\\

	\noindent $\MultWithError{[x]^B}{[y]^B}$: \\
	\indent	$P_i$ has $(x_i, x_{i+1})$ and $(y_i, y_{i+1})$ as
		shares of $[x]^B$ and $[y]^B$ respectively. \\
	\indent Let GFMult() represent a Galois-field multiplication 
		in the Galois field of size $2^l$.
		This function use a fixed characteristic polynomial for each $l$.\\
	\indent Each $P_i$ computes $z_i = $ GFMult($x_i$, $y_i$) $\oplus$ 
			GFMult($x_{i+1}$, $y_i$) $\oplus$ GFMult ($x_i$, $y_{i+1}$). \\
	\indent for $i = 0, 1, 2$, execute $[z_i]^B = \InputB{z_i}{P_i}$\\
	\indent Set $[z]^B = \Add{\Add{[z_0]^B}{[z_1]^B}}{[z_2]^B} $\\	
\end{protocol}

