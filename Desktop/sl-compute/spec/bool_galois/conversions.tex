\section{Conversions}

\subsection{Bit Array Conversions}

The Galois ABB is primarily useful for the \SLCompute~platform 
because it allows an alternative representation of bit arrays (or integers)
in which items are members of a \emph{field}.
This, in particular, provides each element with a multiplicative inverse,
allowing, for instance, the creation of information-theoretic MACs.
This section presents how bit arrays stored in the Boolean Bit ABB
can be converted to objects stored in the Galois ABB.
(Integers can also be stored by first being converted to bit arrays.)

We assume that parties use the same local convention for representing
elements of \GFtwol.
This includes each party holding a local function \\
$\GalToPoly{\cdot}$,
which takes as input a local Galois field element $x \in \GFtwol$
and returns a boolean array representing the coefficients of the polynomial 
representation of Galois variable $x$.
In particular, the $i^{th}$ bit in the array represents the coefficient
of the term $w^i$ in the polynomial representation. 
(Note that the lower coefficients therefore appear first.)
A natural approach would be for this to be default representation of Galois
field elements, in which case the function $\GalToPoly{\cdot}$ 
does not need to do anything.
The parties also hold a local function $\PolyToGal{\cdot}$ which is the inverse of
$\GalToPoly{\cdot}$.

\begin{protocol}[Bit Array Conversions]
	\BoolArrToGal{\bitvec{X}}
	\begin{enumerate}
		\item Let $l$ be the bit-length of $X$.
		\item Set $([\{t_{1,j}, s_{1,j}\}_{j=1, \ldots, l}]_1,
			[\{t_{2,j}, s_{2,j}\}_{j=1, \ldots, l}]_2,
			[\{t_{3,j}, s_{3,j}\}_{j=1, \ldots, l}]_3)
			= $\\$map(\GetBitShares(\cdot), \bitvec{X})$.\\
			(That is, $(t_{i,j}, s_{i,j})$ is $P_i$'s
			RSS share of $\bitvec{X_j}$.)
		\item $P_i$ sets $s_{i-1,j} = t_{i,j} \oplus s_{i,j}$
			for each $j=1,\ldots,l$.
		\item $P_i$ sets $\vec{S}_{i-1} = \{s_{i-1, j}\}_{j=1, \ldots, l}$
			and $\vec{S}_i = \{s_{i, j}\}_{j=1, \ldots, l}$.
		\item $P_i$ sets $s_{i-1} = \PolyToGal{\vec{S}_{i-1}}$ \\
			and sets $s_i = \PolyToGal{\vec{S}_i}$
		\item $P_i$'s share is $(s_{i-1}, s_i)$.
	\end{enumerate}

\noindent \GalToBoolArr{\galois{x}}
	\begin{enumerate}
		\item Let $l$ be the value such that $x \in \GFtwol$.
		\item Let $(s_{i-1}, s_i)$ be $P_i$'s share of $x$.
		\item $P_i$ sets $\vec{S}_{i-1} = \GalToPoly{s_{i-1}}$ \\
			and sets $\vec{S}_i = \GalToPoly{s_i}$.
		\item Let $\{s_{i-1,j}\}_{j=1,\ldots,l}$ and
			$\{s_{i,j}\}_{j=1,\ldots,l}$ be the
			bits stored in $\vec{S}_{i-1}$ 
			and $\vec{S}_i$ respectively.
		\item $P_i$ sets $t_{i,j} = s_{i-1,j} \oplus s_{i,j}$
			for each $j=1,\ldots,l$.
		\item $\bitvec{X} =  map(\SetBitFromShares{\cdot}{\cdot}{\cdot},$\\
			$\private{\{(t_{1,j}, s_{1,j})\}_{j=1,\ldots,l}}{1},
			\private{\{(t_{2,j}, s_{2,j})\}_{j=1,\ldots,l}}{2},
			\private{\{(t_{3,j}, s_{3,j})\}_{j=1,\ldots,l}}{3})$. \\
			(That is, the values $\{(t_{i,j}, s_{i,j}\}_{j=1,\ldots,l}$ are used
			as the shares for a Boolean Bit Array, in the natural way.)
	\end{enumerate}

\end{protocol}

Note that the Boolean Bit ABB uses a variant of Replicated Secret Sharing
where rather than $P_i$ storing $(s_{i-1}, s_i)$ as its share,
$P_i$ stores $(s_{i-1} \oplus s_i, s_i)$ as its share.
In terms of security, these representations are identical,
but this representation allows certain calcuations to be more efficient.
However, for the Galois ABB we instead use standard RSS.
This therefore requires a step in the conversions between the 
standard RSS and the RSS variant.

Since the protocol makes use of Boolean Bit ABB function
$\SetBitFromShares{}{}{}$, it is important to verify
that the conditions of this function are met.

\begin{theorem}
	Let $P_b$, $P_{b+1}$ be the honest parties.
	Protocol \GalToBoolArr{} guarantees that in every call to
	function \SetBitFromShares{}{}{},
	the shares $\private{(t_b, s_b)}{b}$ and 
	$\private{(t_{b+1}, s_{b+1})}{b+1}$
	satisfy $t_{b+1} = s_b \oplus s_{b+1}$.
\end{theorem}
\begin{proof}
	We show that the Galois ABB maintains the expected invariant 
	of Replicated Secret Sharing:
	that for any stored value $\galois{x}$,
	$P_b$ and $P_{b+1}$, will always hold a common share $x_b$.
	We can see this is preserved by every function. 
	\begin{itemize}
		\item Public input: this holds trivially, since the shares are set 
		from public values.
		\item Private input: An honest input provider will provide
		the correct common share to each other party.
			A dishonest input provider cannot make the other two (honest) parties 
			agree on an inconsistent third share.
		\item Random values: $P_b$ and $P_{b+1}$ hold a common PRF key,
			and hold a common (public) variable $id$,
			so will create a common output share $y_b$.
		\item Addition: If $P_b$ and $P_{b+1}$ hold a common share
			$x_b$ for input \galois{x},
			and a common share $y_b$ for input \galois{y},
			they will hold a common share $z_b = x_b \Gadd y_b$
			for the output. 
		\item Multiplication by a Constant:
			If $P_b$ and $P_{b+1}$ hold a common share
			$x_b$ for input \galois{x},
			they will hold a common share $z_b = x_b \Gmult c$ of the output.
		\item Multiplication with Error/Inner Product with Error:
			The output shares are the results of the private input function
			so will be consistent (even if they are not correct).
		\item Conversion from Boolean Sharing:
			While an adversary can pick their own shares,
			the shares held by the honest parties will satisfy the condition
			that $t_{b,j} = s_{b,j} \oplus s_{b-1,j}$ for all $j=1,\ldots,l$.
			Therefore the $s_{b,j}$ computed by $P_{b+1}$ will be the same
			as the $s_{b,j}$ held by $P_{b}$.
			Therefore, $P_b$ and $P_{b+1}$ will hold consistent values of share $s_b$.
		\end{itemize}
	Since $P_b$ and $P_{b+1}$ will hold a common share $x_b$,
	then the values $\{s_{b,j}\}_{j=1,\ldots,l}$ held by $P_b$ and $P_{b+1}$ will be consistent.
	Therefore, $P_{b+1}$ will compute $t_{b+1,j} = s_{b,j} \oplus s_{b+1,j}$
	using said common shares of $s_{b, j}$.
	Equivalently, calling $P_b$ $P_{i+1}$ and $P_{b+1}$, $P_{i-1}$
	where $P_i = P_{b-1}$ is the corrupted party,
	the provided shares will satisfy $s_{i-1,j} \oplus s_{i+1,j} = t_{i-1,j}$ 
	for ever $j=1,\ldots,l$, as required.
\end{proof}

In order for a bit array of length $l$ to be representable
as a Galois field element, the parties must have agreed on a 
representation of $\GFtwol$ for that value of $l$.
This includes agreeing on the irreducible polynomial to be used 
for each such $l$.
In some implementations, this may be defined only for particular values
of $l$ of significance,
and \BoolArrToGal{}~should throw an error in the case that 
an array is provided whose length does not have a defined irreducible polynomial.

\subsection{Padding}

Padding can be achieved by each party locally zero-padding their shares.
This therefore does not require any communication.
Note that the higher-order $m-l$ bits of all output shares will be 0.
The output is not, therefore, a uniformly random galois sharing of the secret,
but this is not a problem, as the parties do not gain any additional information,
since they already know that the shares are the result of a padding function.

\begin{protocol}[Padding]
	\GalPad{[x]}{m}:
	\begin{enumerate}
		\item Let $l$ be such that $x \in \GFtwol$.
		\item Let $(x_{i-1}, x_i)$ be the share of $P_i$ for $i \in \{1, 2, 3\}$.
		\item Each party $P_i$ computes 
			$\vec{X}_{i-1} = \GalToPoly{x_{i-1}}$
			and $\vec{X}_i = \GalToPoly{x_i}$.
		\item Each party $P_i$ locally pads their arrays:\\
			$\vec{Y}_{i-1} = \vec{X}_{i-1} || 0^{m-l}$\\
			$\vec{Y}_i = \vec{X}_i || 0^{m-l}$
		\item Each party $P_i$ locally computes:\\
			$y_{i-1} = \PolyToGal{\vec{Y}_{i-1}}$\\
			$y_i = \PolyToGal{\vec{Y}_i}$
		\item Each party $P_i$ locally sets its shares of the output to 
			$(y_{i-1}, y_i)$.
	\end{enumerate}
\end{protocol}
