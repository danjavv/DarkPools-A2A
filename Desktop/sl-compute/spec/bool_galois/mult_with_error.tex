\section{Multiplication With Error}

It is possible for the parties to obtain an additive sharing of a product
of two RSS-shared variables using only local computation.
This can then be transformed into a Replicated Secret Sharing 
by each party inputting its additive share and adding the result.
However, the corrupted party may input an incorrect value,
leading to an inaccurate result. 
Note however that the inputs remain private: the corrupted party
does not receive any new information from this protocol.
Furthermore, the corrupted party knows exactly which error term
was introduced. 

Even though the adversary is able to introduce errors, this protocol
is still useful in many cases.
For instance it can be used to create Message Authentication Codes (MACs)
in which the MAC key is revealed after some computation allowing the MACs to be checked.


\begin{protocol}[Galois Multiplication with Error]
	\GalMultWithError{\galois{x}}{\galois{y}}:
	\begin{enumerate}
		\item Let $\private{(x_i, x_{i+1})}{i}$ and
			$\private{(y_i, y_{i+1})}{i}$
			represent $P_i$'s shares of $x$ and $y$
			respectively.
		\item $P_i$ locally computes 
			$r_i = (x_i \Gmult y_i) \Gadd (x_i \Gmult y_{i+1})
				\Gadd (x_{i+1} \Gmult y_i)$.
			\item For each $i \in \{1,2,3\}$ (in parallel) set\\
				$\galois{r_i} = \InputGalFrom{\private{r_i}{i}}{i}$
		\item Compute $\galois{z} = \galois{r_1} \Gadd \galois{r_2} \Gadd
			\galois{r_3}$
		\item Return $\galois{z}$.
	\end{enumerate}
\end{protocol}

\textbf{Proof sketch:}
We have that $x = x_1 \Gadd x_2 \Gadd x_3$ and $y = y_1 \Gadd y_2 \Gadd y_3$.
By the distributive and commutative properties:\\
\[x \Gmult y = (x_1 \Gadd x_2 \Gadd x_3) \Gmult (y_1 \Gadd y_2 \Gadd y_3) \] 
	\[= x_1 \Gmult y_1 \Gadd x_1 \Gmult y_2 \Gadd x_1 \Gmult y_3 \Gadd \]
	\[ x_2 \Gmult y_1 \Gadd x_2 \Gmult y_2 \Gadd x_2 \Gmult y_3 \Gadd \]
	\[ x_3 \Gmult y_1 \Gadd x_3 \Gmult y_2 \Gadd x_3 \Gmult y_3 \]
	\[= (x_1 \Gmult y_1 \Gadd x_1 \Gmult y_2 \Gadd x_2 \Gmult y_1) \Gadd \]
	\[(x_2 \Gmult y_2 \Gadd x_2 \Gmult y_3 \Gadd x_3 \Gmult y_2) \Gadd \]
	\[(x_3 \Gmult y_3 \Gadd x_3 \Gmult y_1 \Gadd x_1 \Gmult y_3)\]
If each party inputs the correct value of $r_i$, then the above term
will be $r_1 + r_2 + r_3 = z$.
However a corrupted party $P_j$ may input 
$r_j = x_j \Gmult y_j \Gadd x_j \Gmult y_{j+1} \Gadd x_{j+1} \Gmult y_j \Gadd \delta$
for some arbitrary term $\delta$.
Therefore the output $z$ will be equal to $x \Gmult y \Gadd \delta$,
where $\delta$ is an arbitrary term chosen by the adversary.


