\section{Shuffle}

\subsection{A Permutation With Additive Errors}

The shuffle protocol is derived from the 3-party shuffle of
Laur et al. \cite{EPRINT:LauWilZha11}.
The idea is as follows. 
We first observe a simple protocol for permuting an array
according to a pseudorandom permutation known by 2 of the parties, 
$P_i$ and $P_j$, but not the third.
The data is secret-shared (e.g. with an additive sharing) 
between $P_i$ and $P_j$.
$P_i$ and $P_j$ locally permute their shares according to the permutation.
They then re-share the permuted array between all 3 parties.
If this 2-party permutation is repeated 3 times,
with each party taking a turn to be the uninvolved party,
the combined permutation used to shuffle the data will 
not be known by any party.

The 2-party permutation protocol above is only secure against 
a semi-honest adversary (who follows the protocol). 
If $P_i$ or $P_j$ is malicious, the party can input an incorrect value 
during the re-sharing phase.
Nevertheless, the protocol still provides \emph{privacy}
against a malicious adversary corrupting one party.
Furthermore, a malicious adversary can only introduce 
\emph{additive} errors in to the result.
As such, we can view it as a functionality in the 
malicious setting which allows the adversary to introduce errors,
which are added (in the appropriate group) to the true result.
This is similar to how an adversary can introduce errors in the protocol
$\GalMultWithError{}{}$.
We will show how this protocol can be used to build an
errorless shuffle protocol.
First, though, we formally present the functionality
that this building block achieves,
formally present the protocol, 
and prove that the protocol implements the functionality.
Since our final shuffle protocol will need data to be stored
in the Galois ABB, this protocol uses the Galois ABB as well.

\begin{functionality}[Two Party Shuffle With Error]
	\PairShuffle{\gvec{B}}{\twoPrivate{\pi}{i}{j}}\\
		Here $\gvec{B}$ is of length $n$ and
			$\pi: \{0,\ldots,n-1\} \rightarrow \{0,\ldots,n-1\}$.
		Let $l$ be such that each $B_t \in \GFtwol$.
		$P_i$ and $P_j$ are distinct parties, both holding $\twoPrivate{\pi}{i}{j}$.\\
		If $P_i$ or $P_j$ is the corrupted party, 
			the adversary inputs an arbitrary error array
			$\Delta \in \GFtwol^n$. 
		Otherwise set $\Delta = 0^n$.\\
		Set $C_t = B_{\pi(t)} \Gadd \Delta_t$ for $t \in \{0, \ldots, n-1\}$.\\
		Return $\gvec{C}$.
\end{functionality}


\begin{protocol}[Two Party Shuffle With Error]
	\PairShuffle{\gvec{B}}{\twoPrivate{\pi}{i}{j}}
	\begin{enumerate}	
		\item Let $l$ be such that elements of $\gvec{B}$ are from GF($2^l$).
			Let $n$ be the array length of $\gvec{B}$.
		\item Choose $a$ such that $\{a, a+1\} = \{i, j\}$.
		\item Reshare $\gvec{B}$ between $P_a$ and $P_{a+1}$ using an additive 
			sharing over GF($2^l$):
			\begin{enumerate}
				\item $\{\private{\{(B_{u-1, t}, B_{u, t})\}_{t=0,\ldots,n-1}}{u}\}_{u=1,2,3} = \\
					\GetGalShares{\gvec{B}}$
				\item $P_a$ locally computes $\{\private{C_t}{a} = B_{a-1,t} \Gadd B_{a,t}\}_{t=0,\ldots,n-1}$.\\
			
				\item $P_{a+1}$ locally assigns $\{\private{D_t}{a+1} = B_{a+1, t}\}_{t=0,\ldots,n-1}$.
			\end{enumerate}
		\item $P_a$ and $P_{a+1}$ locally permute their private shares of the array 
			according to $\pi$, that is for all $t=0,\ldots,n-1$:\\
			$\private{E_t}{a} = \private{C_{\pi(t)}}{a}$\\
			$\private{F_t}{a+1} = \private{D_{\pi(t)}}{a+1}$
		\item $P_a$ and $P_{a+1}$ input their shares of the permuted arrays:\\
			$\gvec{E} = \InputGalFrom{\private{\vec{E}}{a}}{a}$\\
			$\gvec{F} = \InputGalFrom{\private{\vec{F}}{a+1}}{a+1}$	
		\item The permuted array is constructed:\\
			$\gvec{G} = $map$(\Gadd, \gvec{E}, \gvec{F})$
		\item Output $\gvec{G}$
	\end{enumerate}
\end{protocol}

\begin{theorem}
	Protocol $\PairShuffle{}{}$ securely implements Functionality $\PairShuffle{}{}$ in the $(3,1)$-secure malicious setting.
\end{theorem}

\begin{proof}
	The only outputs to the parties are those of $\GetGalShares{\cdot}$.
	Note, however, that the adversary \emph{selects its own output}
	in this functionality, so the simulator can choose the same output
	as that generated by the real-world adversary.

	If neither $P_i$ nor $P_j$ are corrupted,
	the function will be computed correctly by the honest parties,
	since:\\ 
	$\vec{G}_t = \vec{E}_t \Gadd \vec{F}_t
			= \vec{C}_{\pi(t)} \Gadd \vec{D}_{\pi(t)}
			= \vec{B}_{i-1, \pi(t)} \Gadd \vec{B}_{i, \pi(t)} \Gadd \vec{B}_{i+1, \pi(t)}
			= \vec{B}_{\pi(t)}$ \\
	
	If $P_i$ or $P_j$ is corrupted,
	the corrupted party may input an incorrect result.
	The simulator can calculate what the correct input would have been
	(as it has access to the permutation, \twoPrivate{\pi}{i}{j},
	and its' self-chosen shares).
	It can therefore compute $\Delta$, the difference between the adversary-provided
	input and the correct input. 
	It can use this same $\Delta$ as its input to the \PairShuffle{}{} functionality,
	causing the value stored in the ABB to be the same as it would have been
	in the real protocol execution.
\end{proof}



\subsection{Errorless Shuffle Protocol using Message Authentication Codes}

In order to protect against this, we add \emph{Message Authentication Codes}
or MACs.
A MAC is a tag which is generated from an item and a secret (or secret-shared) key.
A checking algorithm uses the secret key to verify that a tag is correct for a given item.
The shuffle protocol will create a MAC for each item
and secret-share the MACs with the items.
The MACs will then be shuffled using the same permutation as the array items.
After the permutation, the protocol will check that all of the MACs are correct.
While the adversary can introduce an additive error to the array items and to the MACs,
the MAC ensures it is unlikely that they will be able to introduce the
correct error to the MAC that will allow the MAC to still be a correct tag.

In the cryptographic literature, MACs usually provide security
against an adversary who can perform arbitrary manipulations on 
both the data and the MAC.
However, in this case the adversary will be restricted in that it can only
introduce additive errors (in some group) to the input and the MAC.
Therefore, we are able to use a very simple ``MAC'' protocol,
namely multiplication (in some field) by a secret-shared MAC key.
Even though this function does not satisfy the definition of a MAC against a 
general adversary,
it does satisfy the requirement of unforgeability against the restricted
adversary encountered in our MPC protocol.
We therefore follow the common practice in the MPC literature of still
referring to the function and tag as a MAC
(see for instance \cite{C:DPSZ12}). 

Our protocol is taken from \cite{CCS:AHIKNPTT22}, with minor modifications.
In order to create MACs for data in $\{0,1\}^l$, 
we convert data to representations in $\GFtwol$.


\begin{protocol}[Shuffle]
	\Shuffle{\bvec{B}}:
	\begin{enumerate}
		\item Let $l$ be the bit-length of the integers in $\bvec{B}$
			and let $n$ be the length of the array $\bvec{B}$.
		\item \gvec{B} = map(\BoolArrToGal{\InttoBitArr{\cdot}}, \bvec{B})
		\item In parallel for each $i \in \{1,2,3\}$, 
			$P_i$ sends $P_{i+1}$ a PRF key $k_i$.
			$P_i$ and $P_{i+1}$ locally use $\twoPrivate{k_i}{i}{i+1}$
			to locally generate a pseudorandom permutation
			$\twoPrivate{\pi_i}{i}{i+1}$.
		\item The parties generate a random secret-shared MAC key:\\
			$\galois{\alpha} = \GalRand{l}$
		\item The MACs are generated:\\
			$\gvec{U} = map(\GalMultWithError{}{}, \galois{\alpha}, \gvec{B})$
		\item The first pair of parties perform the first permutation on the data and MACs
			(in parallel):\\
			$\gvec{C} = \PairShuffle{\gvec{B}}{\twoPrivate{\pi_1}{1}{2}}$ \\
			$\gvec{V} = \PairShuffle{\gvec{U}}{\twoPrivate{\pi_1}{1}{2}}$
		\item The second pair of parties perform the second permutation on the data and 
			MACs (in parallel):\\
				$\gvec{D} = \PairShuffle{\gvec{C}}{\twoPrivate{\pi_2}{2}{3}}$ \\
				$\gvec{W} = \PairShuffle{\gvec{V}}{\twoPrivate{\pi_2}{2}{3}}$
		\item The third pair of parties perform the third permuation on the data and MACs
			(in parallel): \\
				$\gvec{E} = \PairShuffle{\gvec{D}}{\twoPrivate{\pi_3}{3}{1}}$ \\
				$\gvec{X} = \PairShuffle{\gvec{W}}{\twoPrivate{\pi_3}{3}{1}}$
		\item A random checksum array is generated (locally):\\ 
			$\gvec{A} = map(1^{3n}, \GalRand{l})$.
		\item The checksum is applied to both the data and the MACs (in parallel):\\
			$\galois{s} = 
				\GalInnerProdWithError{\gvec{A}}{\gvec{C} || \gvec{D}|| \gvec{E}}$\\
			$\galois{t} = \GalInnerProdWithError{\gvec{A}}{\gvec{V} || \gvec{W} || \gvec{X}}$
		\item The combined MAC is checked:\\
			$\galois{u} = \GalMultWithError{\galois{s}}{\galois{\alpha}} \Gadd \galois{t}$\\
			$u = \OutputGal{\galois{u}}$
		\item If $u \neq 0$, the parties abort the protocol.
		\item \bvec{E} = map(\BitArrtoInt{\GalToBoolArr{\cdot}}, \gvec{E}).\\
			Return $\bvec{E}$.
	\end{enumerate}
\end{protocol}


\begin{theorem}
	Protocol \Shuffle{} securely implements functionality \Shuffle
	in the (3,1)-secure malicious setting.
\end{theorem}
\begin{proof}
	

\end{proof}

