\section{Conversion}

This section presents how values in the Arithmetic integer ABB can be converted to the Boolean integer ABB, and vice versa.
These conversions enable the use of the most appropriate sharing format for each operation, allowing the Silent Compute platform to optimize performance by leveraging the strengths of different secret-sharing schemes.

Arithmetic sharing is well-suited for operations such as {\bf addition} and {\bf multiplication}, while Boolean sharing is more efficient for operations like {\bf comparisons}.
By selecting the sharing type based on the nature of the operation, we achieve significantly better efficiency than using a single sharing scheme throughout the computation.

The Arithmetic-to-Boolean and Boolean-to-Arithmetic conversion protocols were first introduced in the semi-honest two-party setting in \cite{NDSS:DemSchZoh15}, and later improved in \cite{USENIX:PSSY21}.
The three-party malicious-secure versions of these protocols, which we adopt in this work, were presented in Section $5.3$ of \cite{CCS:MohRin18}.
We adapt these protocols to work with the RSS sharing format used in our platform.

The conversions rely on two core components: the Full Adder ($\FA$) and the Parallel Prefix Adder ($\PPA$). We present both conversion protocols in detail below.

\begin{protocol}[Full Adder]
	$\FAdder{\bit{x_1}}{\bit{x_2}}{\bit{x_3}}$:
    The protocol takes as input Boolean sharings of two bits, $x_1$ and $x_2$, along with a carry bit $x_3$.
    It outputs Boolean sharings of a carry bit $c$ and a sum bit $d$, where $d$ represents the bit-wise addition of the input bits.
    \begin{enumerate}
        \item $\bit{sum} = \bit{x_1} \oplus \bit{x_2}$
        \item $\bit{carry_1} = \And{\bit{x_1}}{\bit{x_2}}$
        \item $\bit{d} = sum \oplus \bit{x_3}$
        \item $\bit{carry_2} = \And{\bit{sum}}{\bit{x_3}}$
        \item $\bit{c} = \bit{carry_1} \oplus \bit{carry_2}$
        \item Return $(\bit{c}, \bit{d})$.
    \end{enumerate}
\end{protocol}

\begin{protocol}[Parallel Prefix Adder]
	$\PPAdder{\bint{x_1}}{\bint{x_2}}$:
    The protocol takes as input two Boolean integer shares $\bint{x_1}$ and $\bint{x_2}$, and outputs their sum.
    \begin{enumerate}
        \item $(\bint{d}, \bit{c}) = \Add{\bint{x_1}}{\bint{x_2}}$
        \item Return $\bint{d}$.
    \end{enumerate}
\end{protocol}

\subsection{Arithmetic Integer ABB to Boolean Integer ABB}

The idea of the protocol is for the parties to input their shares of the Arithmetic value $\aint{x}$ into a Boolean circuit that computes their sum.
The use of the Parallel Prefix Adder ($\PPA$) and Full Adder ($\FA$) enables an efficient realization of this circuit, reducing the communication complexity to $\mathcal{O}(l + l\log l)$ and the round complexity to $1 + \log l$ rounds.

\begin{protocol}[Arithmetic Integer to Boolean Integer]
	$\ArithtoBitArr{\aint{x}}$:
    The input of this protocol is an arithmetic sharing $\aint{x}$ of a value $x \in \Ztwol$, where $(t_1, s_1), (t_2, s_2)$ and $(t_3, s_3)$ are the shares of $P_1, P_2$ and $P_3$, respectively.
    The protocol converts it to a vector of Boolean shares $\{\bit{x_i}\}_{i = 1, \ldots, l}$ such that $x = \sum_{i = 1}^{i = l}2^{i - 1}x_i$.
	\begin{enumerate}
		\item Locally convert $\aint{x}$ to the sharings of the following:
		\begin{enumerate}
            \item $\bint{s_1}: (s_1, s_1), (t_2 - s_2, 0), (0, 0)$
            \item $\bint{s_2}: (0, 0), (s_2, s_2), (t_3 - s_3, 0)$
            \item $\bint{s_3}: (t_1 - s_1, 0), (0, 0), (s_3, s_3)$
        \end{enumerate}
        \item for $i = 0$ to $i = l - 1$ (in parallel):
            $$(\bit{c_i}, \bit{d_i}) = \FAdder{\bint{s_1}.data[i]}{\bint{s_2}.data[i]}{\bint{s_3}.data[i]}$$
        where $\bint{c}.data[i] = \bit{c_i}$ and $\bint{d}.data[i] = \bit{d_i}$.
        \item $\bint{x} = \PPAdder{2\bint{c}}{\bint{d}}$
        \item Return $\InttoBitArr{\bint{x}}$.
	\end{enumerate}
\end{protocol}

\subsection{Boolean Integer ABB to Arithmetic Integer ABB}

The Boolean-to-Arithmetic integer conversion protocol uses a gadget called {\bf CommonRandomBooleanInt} which takes as input the party indices $i$ and $i - 1$.
This protocol returns a shared value, denoted $\bint{r}$, corresponding to a random Boolean integer $r$, and $\twoPrivate{r}{i}{i - 1}$, which indicates that parties $P_{i - 1}$ and $P_i$ hold $r$.
The protocol uses a pseduorandom function (PRF) $F: \{0, 1\}^\kappa \times \{0, 1\}^\kappa \rightarrow \{0, 1\}^l$, whose output bits encode a Boolean integer. 
This protocol is based on the technique described in Section $5.3$ of \cite{CCS:MohRin18}.

\begin{protocol}[Generate Common Random Boolean Integer]
	$\CommonRandomBooleanInt{i}{i - 1}$:
    Parties $P_i$ and $P_{i - 1}$ hold three PRF keys $k_{i - 1}, k_i, k_{i + 1}$ and party $P_{i + 1}$ hold $k_i, k_{i + 1}$.
	\begin{enumerate}
        \item Each party $P_j$ for $j \in \{1, 2, 3\}$ computes $s_{j - 1} = F(k_{j - 1}, N)$ and $s_j = F(k_j, N)$, where $N$ denotes a public nonce.
        \item Parties $P_i$ and $P_{i - 1}$ set $$\twoPrivate{r}{i}{i - 1} = F(k_{i - 1}, N) + F(k_{i}, N) + F(k_{i + 1}, N)$$
        \item Each party $P_j$ for $j \in \{1, 2, 3\}$ outputs $(s_{j - 1} + s_j, s_j)$.
	\end{enumerate}
\end{protocol}

The Boolean-to-Arithmetic conversion protocol reuses the same circuit as the Arithmetic-to-Boolean protocol, with a slight reordering of operations.
Initially, parties $P_2$ and $P_3$ generate a random Boolean share $\bint{a_2}$, and parties $P_1$ and $P_3$ generate $\bint{a_3}$, using the {\bf CommonRandomBooleanInt} protocol.
These values form part of the final Arithmetic sharing, where $a_2$ is known to $P_2$ and $P_3$, and $a_3$ is be known to $P_1$ and $P_3$, as determined by the protocol.

Subsequently, the parties then use the Parallel Prefix Adder ($\PPA$) and Full Adder ($\FA$) to compute the value $\bint{s_1}$, which is then revelaed to parties $P_1$ and $P_2$.
The overall conversion requires $1 + \log l$ rounds and $l + \log l$ gates.

\begin{protocol}[Boolean Integer to Arithmetic Integer]
	$\BitArrtoArith{\bint{x}}$:
    The input of this protocol is a boolean integer sharing, $\bint{x}$, corresponding to a vector of Boolean shares $\{\bit{x_i}\}_{i = 1, \ldots, l}$, which encode the integer $\sum_{i = 1}^{i = l}2^{i - 1}x_i$.
    The protocol converts it to an arithmetic sharing, $\aint{x}$, of $x \in \Ztwol$.
	\begin{enumerate}
        \item $\bint{a_2}, \twoPrivate{a_2}{3}{2} = \CommonRandomBooleanInt{3}{2}$
        \item $\bint{a_3}, \twoPrivate{a_3}{1}{3} = \CommonRandomBooleanInt{1}{3}$
        \item for $i = 0$ to $i = l - 1$ (in parallel):
            $$(\bit{c_i}, \bit{d_i}) = \FAdder{\bint{x}.data[i]}{\bint{a_2}.data[i]}{\bint{a_3}.data[i]}$$
        where $\bint{c}.data[i] = \bit{c_i}$ and $\bint{d}.data[i] = \bit{d_i}$.
        \item $\bint{s_1} = \PPAdder{2\bint{c}}{\bint{d}}$
        \item $\OutputIntTo{\bint{s_1}}{1}$, $\OutputIntTo{\bint{s_1}}{2}$
        \item Parties set shares as follows (where the shares are encoded as integers):  
        \begin{itemize}
            \item $P_1$ computes $s_3 = 2^l - a_3$, and set its share as $(s_3 \Aadd s_1, s_1)$.
            \item $P_2$ computes $s_2 = 2^l - a_2$, and set its share as $(s_1 \Aadd s_2, s_2)$.
            \item $P_3$ computes $s_2 = 2^l - a_2, s_3 = 2^l - a_3$, and set its share as $(s_2 \Aadd s_3, s_3)$.
        \end{itemize}
	\end{enumerate}
\end{protocol}