\section{Input and Output From/To Replicated Secret Shares}

In general, we will wish to ignore the fact that the functionality
for storing and manipulating secret data is implemented by secret-sharing.
However, in a few cases, later protocols access secret shares directly,
for instance to perform conversion between ABB types without communication.
In order to represent this in the abstraction, the functionality also
contains functions \GetBitShares{} and \SetBitFromShares{}{}{}
which, respectively, allow the obtaining of RSS shares and setting of 
ABB values from shares.

Note that our functionality allows the adversary to determine the shares
they receive (and provides shares consistent with this to the honest parties).
The real-world adversary will not have such powers.
This is not an issue, as security depends on the ideal-world adversary
(or simulator) being able to simulate anything that the real-world adversary
would do or learn, not the other way round.
As such our simulator will limit themselves to providing shares that 
are consistent with a real-world execution of the protocol.
In short, allowing the adversary to choose their own shares
captures the fact that the choice of shares should not matter to
any protocol that calls the functionality, as long as the shares
are consistent with the secret value stored and the adversary
does not gain additional information from the provided shares.
Furthermore, it means that the functionality does not need to
keep track of secret-sharing representations;
in the proof this will be done by the simulator.

The protocols for implementing this are the expected trivial protocols:

\begin{protocol}[IO from Replicated Secret Shares]
	\GetBitShares{\bit{x}}:
		Let $(t_j, s_j)$ be the share held by party $P_j$ to represent $\bit{x}$.
		Each $P_j$ locally returns $(t_j, s_j)$.\\

\noindent	\SetBitFromShares{\private{(t_1, s_1)}{1}}{\private{(t_2, s_2)}{2}}{\private{(t_3, s_3)}{3}}:
		Each $P_j$ uses $(t_j, s_j)$ as their shares for the newly created variable.

\end{protocol}

\noindent Note that there is no check in $\SetBitFromShares{}{}{}$ to ensure that the secret-sharing is
consistent. The burden is on whichever function calls $\SetBitFromShares{}{}{}$ to ensure
that (honest) parties provide consistent secret-shares.



