\section{Boolean Bit ABB Functionality}

The Boolean Bit ABB allows the inputting and outputting of bits,
and basic operations on these bits.
To allow for efficient conversions to other types (i.e. other ABBs),
the Boolean Bit ABB also provides an abstraction 
that corresponds to accessing and setting local shares directly.
These functions would not be exposed to a general user of the system.
The functionality of the Boolean Bit ABB is summarized in the definition below.
More detailed descriptions, as well as the protocols implementing
each of these functionalities, will be presented in later sections.


\begin{functionality}

    \Setup: Initialize the ABB. \\

    \RandBit: Return $\bit{0}$ or $\bit{1}$, each with probability $\frac{1}{2}$.\\

    \InputBit{x}: Given a public bit $x$, store it in the ABB
        and return a public identifier to the variable. 
        (Shorthand: $\bit{x}$.)\\
    
    \InputBitFrom{x}{i}:  Given a private bit, $\private{x}{i}$, held by $P_i$,
        store it in the ABB and return a public identifier to the variable.
        Note that $P_i$'s local \emph{identifier} for $\private{x}{i}$ can 
        also be private to $P_i$. \\
    
    \OutputBit{\bit{x}}: Given a bit stored in the ABB under identifier $x$,
        reveal it to all parties. \\
    
    \OutputBitArray{\bit{\vec{X}}}: Given an array of bits stored in the ABB under identifier $\vec{X}$,
        reveal it to all parties. (Define: \bit{\vec{X}} = \{\bit{x_1}, \ldots, \bit{x_l}\}.) \\
        
    \OutputBitTo{\bit{x}}{i}: Given a bit stored in the ABB under identifier $x$,
        reveal it to $P_i$.  \\

    \OutputArrayofBitsTo{\bit{\vec{X}}}{i}: Given an array of bits stored in the ABB under identifier $\vec{X}$,
        reveal $\vec{X}$ to $P_i$. (Define: \bit{\vec{X}} = \{\bit{x_1}, \ldots, \bit{x_l}\}.) \\

	\Not{\bit{x}}: Return \bit{x \oplus 1}. (Shorthand: $\neg \bit{x}$.) \\

    \GetBitShares{\bit{x}}: \bit{x} is a bit stored in the ABB. \\
	The adversary, $P_i$, selects $(t_i, s_i)$ and sends it to the functionality.\\
	The functionality computes $s_{i-1} = s_i \oplus t_i$
	and $s_{i+1} = x \oplus s_{i} \oplus s_{i-1}$.\\
	The functionality computes $t_j = s_j \oplus s_{j-1}$ for $j \in \{i-1, i+1\}$.\\
	The functionality sends $(t_j, s_j)$ to $P_j$ for $j \in \{i-1, i+1\}$.\\
	Each party, $P_j$, stores $(t_j, s_j)$ as its share.\\

	\SetBitFromShares{\private{(t_1, s_1)}{1}}{\private{(t_2, s_2)}{2}}{\private{(t_3, s_3)}{3}}:\\
	That is each party $P_j$ sends its own shares $(t_j, s_j)$.\\
	Let $P_i$ be the adversary. Ignore the inputs of $P_i$.\\
	The functionality assumes that $s_{i-1} \oplus s_{i+1} = t_{i-1}$ 
	(i.e. the honest parties provide a consistent sharing),
	if not the behaviour is undefined.\\
	Compute $x = t_{i+1} \oplus s_{i-1}$. 
	Store $x$ in the the ABB and return a public identifier to the variable. \\

    \XOR{\bit{x}}{\bit{y}}: Return \bit{x \oplus y}.  (Infix: $\bit{x} \oplus \bit{y}$.)  \\ 

    \And{\bit{x}}{\bit{y}}: Return \bit{x \wedge y}. (Infix: $\bit{x} \wedge \bit{y}$.)  \\

    \Or{\bit{x}}{\bit{y}}: Return \bit{x \vee y}. (Infix: $\bit{x} \vee \bit{y}$.) \\
    
    \IfThenElse{\bit{c}}{\bit{x}}{\bit{y}}: If $c=1$ return $\bit{x}$, else return $\bit{y}$.

\end{functionality}
