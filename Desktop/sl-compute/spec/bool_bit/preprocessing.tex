\section{Boolean Pre-Processing}
\label{sec:preprocessing}

We compute non-linear operations (AND and OR gates) efficiently by pre-generating
Beaver triples, which are used to check non-linear gates.
Specifically, we use the on-demand variant of \cite{SP:ABFLLN17}.
The details of the protocol are presented below.
Proofs of security can be found in \cite{SP:ABFLLN17}.

\subsection{Coin Tossing}

The coin tossing protocol allows parties to generate a sequence of random bits, denoted as $x_1, \ldots, x_s \in \{0, 1\}$. 
To do this, the parties invoke the {\bf RandomBit} protocol, which generates secret-shares of random bits. 
Once parties have the random bits in a secret-shared manner, the {\bf OutputWithoutVerification} protocol is used to reconstruct and output the random bits.

However, since a malicious party may attempt to send incorrect bits during the {\bf OutputWithoutVerification} protocol, the parties run a safeguard procedure called the {\bf VerifyArrayofBits} which efficiently ensures that all parties involved in the protocol are in agreement and that the generated random bits are valid.    

\begin{protocol}
    \label{protocol:coin_toss}
    \CoinToss{s}
    \begin{enumerate}
        \item The parties invoke $s$ calls in parallel to $\RandBit$. The shares that they receive are denoted as $\bit{x_1}, \ldots, \bit{x_s}$.
        \item The parties run $\OutputWithoutVerification{\bit{x_j}}$ in parallel for each $j \in \{1, \ldots, s\}$ to obtain $x_j$.
        \item The parties run $\VerifyArrayofBits{x_1, \ldots, x_s}$. If a party receives $false$, then it outputs $\bot$. Otherwise, it outputs $x_1, \ldots, x_s$.
    \end{enumerate}
\end{protocol}

\subsection{Random Shuffle}

In the preprocessing protocol, we will need to compute a random permutation of an array of elements.
Let $\genvec{d}$ be the input vector containing $M$ elements, 
i.e., $\genvec{d} = ([d_1], \ldots, [d_M])$.
The protocol generates a random permutation $\pi$ over the set $\{1, \ldots, M\}$ and outputs a vector $\genvec{d'}$ where the elements are permuted according to $\pi$.
Specifically, the new vector $\genvec{d'}$ is defined by $\genvec{d_i'} = \genvec{d_{\pi_i}}$ for each $i \in \{1, \ldots, M\}$.
The protocol takes as input a pseudorandom generator (PRG), which is instantiated with a common seed.
This PRG is used to generate random incides for the permutation, and these indices are subsequently used to swap the elements of the input vector $\genvec{d}$.

\begin{protocol}
    \label{protocol:perm}
    \Perm{\genvec{d}}{G} \\
    Let $M$ denote the length of the vector $\genvec{d}$. This protocol takes as input a pseudorandom generator (PRG) $G$ instantiated with a common seed. 
    \begin{enumerate}
        \item For $j = 1, \ldots, M$:
        \begin{enumerate}
            \item The parties call $G.\mbox{output}(\lceil \log (M-j+1) \rceil)$ until it outputs a random index $i \in \{j, \ldots, M\}$.
	    \item Each party swaps $\genvec{d_j}$ and $\genvec{d_i}$.
        \end{enumerate}
        \item Each party outputs the resulting vector $\genvec{d}$.
    \end{enumerate}
\end{protocol}

\subsection{Secure Generation of Multiplication Triples}

We now present the protocol from \cite{SP:ABFLLN17} for securely generating secret-shared multiplication triples.
The protocol takes an integer $N$ as input and outputs a vector of secret-shared multiplication triples of length $N$.

\label{protocol:preprocessing}
\begin{protocol}
    \Preprocessing{N}\\
    This protocol uses a pseudorandom generator (PRG) $G$.\\
    {\bf Auxiliary input:} Parameters $B, C, X, L$ such that $N = (X - C)L$; $N$ is the number of triples to be generated; $B$ is the number of buckets, $C$ is the number of triples opened in each subarray, and $X = \frac{N}{L} + C$ is the size of each subarray.
    \begin{enumerate}
        \item {\bf Generate random shares:} The parties invoke $2M$ calls to \\ $\RandBit{}$, where $M = (N + CL)(B - 1) + N$. The shares that they receive are denoted as $[(\bit{a_i}, \bit{b_i})]_{i = 1}^{M}$.
	\item {\bf Create the array $\vec{D}$ of multiplication triples:} For each $i = 1, \ldots, M$, the parties run in parallel:\\
		$\bit{c_i} = \AndwithError{\bit{a_i}}{\bit{b_i}}$ (Protocol \ref{protocol:AndwithError}).\\
        Denote $\vec{D} = [(\bit{a_i}, \bit{b_i}, \bit{c_i})]_{i = 1}^{M}$, where $\bit{c_i}$ is the result of the protocol but may not be \emph{correct}.
        \item {\bf Cut and bucket:} This step involves an initial verification to ensure that the triples were correctly generated by opening a subset of them.
        \begin{enumerate}
            \item The parties call $\CoinToss{\kappa}$ to output a random seed $s$. 
            Each party instantiates the PRG $G$ with seed $s$ as $G(s)$. 
            \item Each party divides $\vec{D}$ into vectors $\vec{D}_1, \ldots, \vec{D}_B$, where $\vec{D}_1$ has N triples, and each $\vec{D}_j$ for $j = 2, \ldots, B$ contains $N + LC$ triples.
            \item For each $k = 2, \ldots, B$, the parties further divide $\vec{D}_k$ into $L$ subarrays of equal size $X$, labelled $\vec{D}_{k, 1}, \ldots, \vec{D}_{k, L}$.
            \item The parties run $\Perm{\vec{D}_{k, j}}{G(s)}$\footnote{Instead of shuffling the actual triples, we shuffle the indices of the array.} for each $k = 2, \ldots, B$ and $j = 1, \ldots, L$.
            \item The parties run $\Perm{\vec{L}}{G(s)}$, where $\vec{L} = [1, \ldots, L]$ for each $k = 2, \ldots, B$, and apply the permuted $\vec{L}$ to the subarrays in $\vec{D}_k$.
            \item In parallel, for each $k = 2, \ldots, B$ and $j = 1, \ldots, L$, the parties run Protocol \ref{protocol:trip_with_open} (triple verification with opening) for each of the first $C$ triples in $\vec{D}_{k, j}$, and remove them. If any party rejects a check, it sends $\bot$ to both parties and outputs $\bot$.
            \item The remaining triples are then grouped into $N$ sets of triples $\vec{B}_1, \ldots, \vec{B}_N$, each containing $B$ triples. Each bucket $\vec{B}_i$ contains the $i^{th}$ triple from the vectors $\vec{D}_1, \ldots, \vec{D}_B$.
        \end{enumerate}
        \item {\bf Check buckets:} The parties initialize a vector $\vec{d}$ of length $N$. Then, for each $i = 1, \ldots, N$:
        \begin{enumerate}
            \item Denote the triples in $\vec{B}_i$ as $([a_1], [b_1], [c_1]), \ldots ([a_B], [b_B], [c_B])$.
            \item For $j = 2, \ldots, B$, the parties run Protocol \ref{protocol:trip_without_open} (triple verification using another without opening) on input $([a_1], [b_1], [c_1])$ and $([a_j], [b_j], [c_j])$, to verify $([a_1], [b_1], [c_1])$ (i.e., $c_1 = a_1 \wedge b_1)$.
            \item If a party did not output $true$ in every execution, it sends $\bot$ to the other parties and outputs $\bot$.
            \item The parties then set $\vec{d}_i = ([a_1], [b_1], [c_1])$, storing these shares in the $i^{th}$ position of $\vec{d}$.
        \end{enumerate}
        The parties output $\vec{d}$.
    \end{enumerate}
\end{protocol}

The proof of security for the secure generation of multiplication triples is provided in Section III.A of \cite{SP:ABFLLN17}.
\paragraph{\bf Concrete Parameters.} Based on the results from \cite{SP:ABFLLN17}, we set the parameters as follows: $N = 2^{20}$, $B = 2$, $C = 1$, and $L = 2^{9}$.
With these values, the adversary's probability of winning is at most $2^{-40}$.

Note that, in order to utilize the preprocessing protocol with these parameters, the parties must execute the circuit computation protocol as outlined in Protocol 3.9 of \cite{SP:ABFLLN17}. This protocol specifies how many multiplication triples are generated and subsequently used on-demand when secure computation requests are received.

\subsection{Triple Verification With Opening}

As suggested by the name, the protocol involves verifying the correctness of a multiplication triple $(x, y, z)$, where $z = x \wedge y$, using the {\bf OutputBit} protocol.
The main purpose of this verification process is to ensure that the shares corresponding to the triple are consistent and that the relationship $z = x \wedge y$ holds.
If the consistency condition is violated, the protocol will abort to prevent further malicious behavior.

\begin{protocol}
    \label{protocol:trip_with_open}
    \TripleWithOpen{x}{y}{z}
    \begin{enumerate}
        \item The parties run, in parallel, 
		$\OutputWithoutVerification{\bit{x}}$, 
		$\OutputWithoutVerification{\bit{y}}$ and 
		    \\ $\OutputWithoutVerification{\bit{z}}$. Let $x_i, y_i$ and $z_i$ be the outputs received by $P_i$ in the openings.
        \item Each $P_i$ verifies whether $z_i = x_i \wedge y_i$. If no, it sends $\bot$ to both parties and aborts.
        \item If no $\bot$ messages are received, each party outputs $\accept$.
    \end{enumerate}
\end{protocol}

The fact that the bits are output using $\OutputWithoutVerification{}$
means that the two honest parties may obtain different outputs.
Specifically, if $P_j$ is corrupted, $P_{j+1}$ may obtain outputs that have been
modified by the adversary.
Nevertheless, $P_{j-1}$ will receive correct shares from $P_{j+1}$, 
so will output the true values of $x$, $y$, and $z$.
For clarity, we always consider the true value held by the sharing to be the one
that would be obtained from the honest parties' shares.
$P_{j+1}$ will therefore be able to identify if the triple is incorrect and if so,
will cause the protocol to abort.

\subsection{Triple Verification Without Opening (Using Another)}

The {\bf Triple Verification With Opening} procedure allows parties to check a triple by opening it and revealing its values $x, y$ and $z$.
Such a triple can no longer be used in the protocol.
The {\bf Triple Verification Without Opening} procedure verifies a multiplication triple is consistent without opening it, by using (sacrificing) an additional random multiplication triple that is assumed to be consistent.

\begin{protocol}
    \label{protocol:trip_without_open}
    \TripleWithoutOpen{x}{y}{z}\\
    {\bf Input:} The parties hold a triple $(\bit{a}, \bit{b}, \bit{c})$.
    \begin{enumerate}
        \item Each party locally computes $\bit{\rho} = \bit{a} \oplus \bit{x}$ and $\bit{\sigma} = \bit{b} \oplus \bit{y}$.
        \item The parties run $\OutputBit{\bit{\rho}}$ and $\OutputBit{\bit{\sigma}}$.
        If a party receives $\bot$ from either of the openings, it sends $\bot$ to both parties and outputs $\bot$.
        Otherwise, let $\rho_i$ and $\sigma_i$ be the outputs received by $P_i$ during the openings.
        \item Each party $P_i$ computes $\bit{c} \oplus \bit{z} \oplus \sigma_i \wedge \bit{x} \oplus \rho_i \wedge \bit{y} \oplus \rho_i \wedge \sigma_i$. Let $(t_i, s_i)$ be the result of the computation held by the party $P_i$.
        \item $P_i$ sends $t_i$ to $P_{i + 1}$. Upon receving $t_{i - 1}$ from $P_{i - 1}$, party $P_i$ checks that $s_i = t_{i - 1}$. If yes, it outputs $\accept$; else, it sends $\bot$ to both parties and outputs $\bot$.
    \end{enumerate}
\end{protocol}

In Step $3$, each party computes $\bit{c} \oplus \bit{z} \oplus \sigma_i \wedge \bit{x} \oplus \rho_i \wedge \bit{y} \oplus \rho_i \wedge \sigma_i$, which is equivalent to $\bit{z} \oplus (\bit{x} \wedge \bit{y})$ provided that $\bit{a} \wedge \bit{b} = \bit{c}$.
This should be $0$ if $(\bit{x}, \bit{y}, \bit{z})$ is indeed a correct multiplication triple.
This implies that the result of this computation must satisfy the relation $s_i \oplus s_{i - 1} \oplus s_{i + 1} = 0$. In other words, $s_i =  s_{i - 1} \oplus s_{i + 1} = t_{i - 1}$.
Hence, in Step $4$, each party $P_i$, upon receiving $t_{i - 1}$ from $P_{i - 1}$, checks whether $s_i = t_{i - 1}$. A detailed proof of correctness can be found in \cite{EC:FLNW17}. \\

\noindent We now present a batched version of the above protocol. 
Specifically, the batched protocol takes as input a vector of triples.
\begin{itemize}
    \item {\bf Step 1:} The parties generate two vectors, $\vec{ver}$ and $\vec{rep}$ of multiplication triples.
    These vectors represent the verification and replacement vectors, respectively.
    \item {\bf Step 2:} The parties assign multiplication triples to be used for verifying the input triples, following Protocol $3.9$ of \cite{SP:ABFLLN17}.
    \item {\bf Step 3:} The parties use the {\bf OutputWithoutVerification} protocol to open the $\rho$ and $\sigma$ values corresponding to the $l$ triples.
\end{itemize}
Finally, hashing is employed to send the verification information, which significantly enhances the communication efficiency of the batched version of the protocol.

\begin{protocol}
    \label{protocol:batch_trip_without_open}
    \BatchTripleWithoutOpen{\{(\bit{x_i}, \bit{y_i}, \bit{z_i})\}_{i = 1}^{l}}\\
    This protocol makes use of a collision resistant hash function $\Hash: \{0, 1\}^{\star} \rightarrow \{0, 1\}^{2 \kappa}$ ($\kappa$ denotes the security parameter) and a pseudorandom generator (PRG) $G$.\\~\\
    {\bf Step 1 - Triple Initialization:} If the vectors $\vec{ver}, \vec{rep}$ are not initialized, the parties execute Protocol \ref{protocol:preprocessing} twice with input $N$, resulting in two vectors $\vec{ver}, \vec{rep}$, each containing sharings of random multiplication triples.\\~\\
    {\bf Step 2 - Generation of Verification Triples:} The parties call $\CoinToss{\kappa}$ to output a random seed $s$.
    Each party instantiates the PRG $G$ with seed $s$ as $G(s)$.
    Initialize an empty vector $\vec{V}$.\\~\\
    For $k = 1, \ldots, l$:
    \begin{enumerate}
        \item The parties call $G(s).\mbox{output}(\log (N))$ until it outputs a random $j \in \{1, \ldots, N\}$.
        \item Add $(\bit{a_j}, \bit{b_j}, \bit{c_j})$ ($j^{\sf th}$ triple in $\vec{ver}$) to the vector $\vec{V}$.
        \item Replace shares of $(\bit{a_j}, \bit{b_j}, \bit{c_j})$ in $\vec{ver}$ with the next unused triple in $\vec{rep}$.\\
        {\it Replenish:} If $\vec{rep}$ is empty (or close to empty) then the parties run Protocol \ref{protocol:preprocessing} with input $N$ to obtain a new $\vec{rep}$.
    \end{enumerate}
    {\bf Step 3 - Batch Verification:}
    \begin{enumerate} 
        \item Each party locally computes $\bit{\rho_j} = \bit{x_j} \oplus \bit{a_j}$ and $\bit{\sigma_j} = \bit{y_j} \oplus \bit{b_j}$ for each $j \in [1, l]$.
        \item The parties run $2l$ instances of {\bf OutputWithoutVerification} with inputs $\bit{\rho_1}, \ldots, \bit{\rho_l}, \bit{\sigma_1}, \ldots, \bit{\sigma_l}$.
        Let $\rho^i_1, \ldots \rho^i_l, \sigma^i_1, \ldots, \sigma^i_l$ be the outputs received by $P_i$ in the openings.
        \item Each party $P_i$ runs $\VerifyArrayofBits{[\rho^i_1, \ldots \rho^i_l, \sigma^i_1, \ldots, \sigma^i_l]}$.
        If it receives $false$, then it sends $\bot$ to both parties and outputs $\bot$.
        \item Each party $P_i$ computes $\bit{z_j} \oplus \bit{c_j} \oplus \sigma^i_j \wedge \bit{a_j} \oplus \rho^i_j \wedge \bit{b_j} \oplus \rho^i_j \wedge \sigma^i_j$. Let $(t_j, s_j)$ be the result of the computation held by the party $P_i$ for each $j \in [1, l]$.
        \item If $l > 2\kappa$, each $P_i$ computes:
        \begin{itemize}
            \item $\tau^i = H(t_1 t_2 \ldots t_l)$.
            Denote $\vec{\tau^i} = \{\tau^i_1, \ldots, \tau^i_{2\kappa}\}$ (where $\tau^i_1, \ldots, \tau^i_{2\kappa}$ denotes the binary representation of $\tau^i$).
            \item $\gamma^i = H(s_1 s_2 \ldots s_l)$. 
            Denote $\vec{\gamma^i} = \{\gamma^i_1, \ldots, \gamma^i_{2\kappa}\}$ (where $\gamma^i_1, \ldots \gamma^i_{2\kappa}$ denotes the binary representation of $\gamma^i$).
        \end{itemize}
        Else:
        \begin{itemize}
            \item Denote $\vec{\tau^i} = \{t_1, \ldots t_l\}$.
            \item Denote $\vec{\gamma^i} = \{s_1, \ldots, s_l\}$.
        \end{itemize}
        Each $P_i$ sends $\vec{\tau^i}$ to $P_{i + 1}$. 
        \item Upon receving $\vec{\tau^{i - 1}}$ from $P_{i - 1}$, party $P_i$ 
        checks that $\vec{\gamma^i} = \vec{\tau^{i - 1}}$. If yes, it outputs $true$; else, it sends $\bot$ to both parties and outputs $\bot$.
    \end{enumerate}
\end{protocol}
