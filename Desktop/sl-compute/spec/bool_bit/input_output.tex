\section{Input, Unauthenticated Output and Consistency Verification}

We present protocols that allow for the sharing of a secret in a way that guarantees a consistent sharing of the input:
\begin{itemize}
    \item The {\bf InputBit} protocol takes as input a public bit $x$. 
    Each party sets a default sharing of the bit $x$ as the output of this protocol.
    Since the parties set their shares locally, this ensures that the protocol generates a consistent sharing of the input value.
    \item The {\bf InputBitFrom} protocol allows a party to generate a random and consistent sharing of a private bit $x$. 
\end{itemize}

\begin{protocol}
    \InputBit{x}
    \begin{enumerate}
        \item Each $P_i$ for $i \in \{1, 2, 3\}$ locally sets its share $(t_i, s_i)$ as follows:
        \begin{itemize}
            \item $P_1$ sets $(t_1, s_1) = (x, x)$.
            \item $P_2$ sets $(t_2, s_2) = (x, 0)$.
            \item $P_3$ sets $(t_3, s_3) = (0, 0)$.
        \end{itemize}
    \end{enumerate}
\end{protocol}

\begin{protocol}
    \InputBitFrom{x}{i}
    \begin{enumerate}
	\item $P_i$ selects $s_i$ at random from $\{0, 1\}$ and computes $s_{i-1} = x \oplus s_i$.
	\item $P_i$ sends $s_{i-1}$ to $P_{i-1}$ and sends $s_i$ to $P_{i+1}$.
	\item $P_{i-1}$ and $P_{i+1}$ set $s_{i+1} = 0$.
	\item Each party $P_j$ computes $t_j = s_j \oplus s_{j-1}$.
		(That is $t_i = x$, $t_{i+1} = s_{i}$, $t_{i-1} = s_{i-1}$.)
	\item Each party $P_j$ sets its share as $(t_j, s_j)$.
    \end{enumerate}
    Parties output $\bit{x}$.
\end{protocol}

Note that $P_i$ can calculate the shares of $P_{i+1}$ and $P_i$.
Since $P_i$ knows the value that was input, this is not a concern
and $P_i$ obtains no additional information by knowing their shares.

\noindent Now, we present a protocol {\bf OutputWithoutVerification}, which takes as input a share $\bit{x}$ and allows each party to learn $x$ without verifying the consistency of the opening.

\begin{protocol}
    \OutputWithoutVerification{\bit{x}}
    \begin{enumerate}
        \item $P_i$ sends $t_i$ to $P_{i + 1}$.
        \item Upon receiving $t_{i - 1}$ from $P_{i - 1}$, $P_i$ outputs $x = s_i \oplus t_{i - 1}$.
    \end{enumerate}
\end{protocol}

We now present a protocol for verifying the consistency of opened values.
It is more efficient to verify the consistency of many bits at a time,
so our verify function takes as input an array. 

\begin{protocol}
    \VerifyArrayofBits{\vec{X}} \\ 
    This protocol makes use of a collision resistant hash function $\Hash: \{0, 1\}^{\star} \rightarrow \{0, 1\}^{2 \kappa}$ ($\kappa$ denotes the security parameter).
    Define: $\vec{X} = \{x_1, \ldots, x_l\}$.
    \begin{enumerate}
        \item If $l > 2 \kappa$, $P_i$ computes $y = H(x_1 x_2 \ldots x_l)$. \\
        Denote $\vec{Y} = \{y_1, \ldots, y_{2\kappa}\}$ (where $y_1 \ldots y_{2\kappa}$ denotes the binary representation of $y$). \\
        Else, denote $\vec{Y} = \{x_1, \ldots, x_l\}$.
        \item $P_i$ sends $\vec{Y}$ to $P_{i + 1}$. 
        If a party receives a value different from $\vec{Y}$, it outputs $false$.
        Otherwise, it outputs $true$.
    \end{enumerate}
\end{protocol}
