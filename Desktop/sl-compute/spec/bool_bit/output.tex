\section{Verification and Output}

In addition to verifying consistency of outputs,
as has already been presented,
we need to be able to verify correctness of outputs.
The following protocol verifies correctness by checking all unverified AND triples (the list $\UnverifiedTriples{}$), again using the efficient batched method.

\begin{protocol}
    \Verify 
    \begin{enumerate}
        \item If $\left|\UnverifiedTriples{i}\right| = 0$, $P_i$ returns.
	\item Otherwise $P_i$ runs \\ $\BatchTripleWithoutOpen{\UnverifiedTriples{i}}$.
		If $P_i$ receives output $true$,
		    $P_i$ sets $\UnverifiedTriples{}$ to the empty list and returns.
		    Otherwise $P_i$ sends $\bot$ to both parties and outputs $\bot$.
    \end{enumerate}
\end{protocol}

\noindent Now, we present protocols that allow parties to open shared values either to a single party or to all of them:
\begin{itemize}
    \item The {\bf OutputBitTo} protocol takes as input a share $\bit{x}$ and a party ID.
    At the end of the protocol, the input party learns the bit $x$ in a verifiable manner.
    \item The {\bf OutputArrayofBitsTo} protocol builds on the {\bf OutputBitTo} protocol.
    It takes as input a vector of shares, and at the end of the protocol, the input party learns the vector in a verifiable manner.
    \item The {\bf OutputBit} protocol takes as input a share $\bit{x}$ and allows the parties to learn $x$ in a verifiable manner.
    \item The {\bf OutputBitArray} protocol takes as input a vector of shares and allows the parties to learn the vector in a verifiable manner.
\end{itemize}

\begin{protocol}
    \OutputBitTo{\bit{x}}{i}
    \begin{enumerate}
        \item The parties run $\Verify$.
        If a party receives $\bot$, it outputs $\bot$. Otherwise it continues.
        \item Parties $P_{i + 1}$ and $P_{i - 1}$ send $t_{i + 1}$ and $t_{i - 1}$, respectively, to $P_i$.
	\item $P_i$ checks that $t_i = t_{i - 1} \oplus t_{i + 1}$.
        If this condition holds, $P_i$ outputs $x = s_i \oplus t_{i - 1}$.
        Otherwise, $P_i$ outputs $\bot$.
    \end{enumerate}
\end{protocol}

\begin{protocol}
    \OutputArrayofBitsTo{\bit{\vec{X}}}{i} \\
    This protocol makes use of a collision resistant hash function $\Hash: \{0, 1\}^{\star} \rightarrow \{0, 1\}^{2 \kappa}$ ($\kappa$ denotes the security parameter).
    Define: $\vec{X} = \{x_1, \ldots, x_l\}$.
    \begin{enumerate}
        \item The parties run $\Verify$.
        If a party receives $\bot$, it outputs $\bot$. Otherwise it continues.
        \item Party $P_{i + 1}$ does the following:
        \begin{itemize}
            \item If $l > 2 \kappa$, compute $y = H(t^{x_1}_{i + 1} \ldots t^{x_l}_{i + 1})$. \\
            Denote $\vec{Y} = \{y_1, \ldots, y_{2\kappa}\}$ (where $y_1 \ldots y_{2\kappa}$ denotes the binary representation of $y$).
            \item Else, denote $\vec{Y} = \{t^{x_1}_{i + 1}, \ldots, t^{x_l}_{i + 1}\}$.
        \end{itemize}
        Party $P_{i + 1}$ sends $\vec{Y}$ to $P_i$.
        \item Party $P_{i - 1}$ sends $\{t^{x_1}_{i - 1}, \ldots, t^{x_l}_{i - 1}\}$ to $P_i$.
        \item Party $P_i$ does the following:
        \begin{itemize}
            \item Denote $u_{i + 1}^{x_j} = t^{x_j}_i \oplus t^{x_j}_{i - 1}$ for each $j \in \{1, \ldots , l\}$.
            \item If $l > 2 \kappa$, compute $w = H(u_{i + 1}^{x_1} \ldots u_{i + 1}^{x_l})$. \\
            Denote $\vec{W} = \{w_1, \ldots, w_{2\kappa}\}$ (where $w_1 \ldots w_{2\kappa}$ denotes the binary representation of $w$).
            \item Else, denote $\vec{W} = \{u_{i + 1}^{x_1}, \ldots, u_{i + 1}^{x_l}\}$.
        \end{itemize}
        $P_i$ checks whether $\vec{W} = \vec{Y}$.
        If this condition holds, $P_i$ outputs $\vec{X} = \{s^{x_1}_i \oplus t^{x_1}_{i - 1}, \ldots, s^{x_l}_i \oplus t^{x_l}_{i - 1}$\}.
        Otherwise, $P_i$ outputs $\bot$.
    \end{enumerate}
\end{protocol}

\begin{protocol}
    \OutputBit{\bit{x}}
    \begin{enumerate}
        \item The parties run $\Verify$. If a party receives $\bot$, it outputs $\bot$.
        \item $P_i$ sends $t_i$ to $P_{i + 1}$.
        \item Upon receiving $t_{i - 1}$ from $P_{i - 1}$, $P_i$ computes $x = s_i \oplus t_{i - 1}$.
	\item The parties run $\VerifyConsistency{x}$. If a party receives $false$ it outputs $\bot$.
		Otherwise, it outputs $x$.
    \end{enumerate}
\end{protocol}

\begin{protocol}
    \OutputBitArray{\bit{\vec{X}}} \\
    Define: $\vec{X} = \{x_1, \ldots, x_l\}$.
    \begin{enumerate}
	 \item The parties run $\Verify$. If a party receives $\bot$, it outputs $\bot$. 
        \item $P_i$ sends $\{t^{x_1}_i, \ldots, t^{x_l}_i\}$ to $P_{i + 1}$.
        \item On receiving $\{t^{x_1}_{i - 1}, \ldots, t^{x_l}_{i - 1}\}$ from $P_{i - 1}$, $P_i$ computes $x_j = s^{x_j}_i \oplus t^{x_j}_{i - 1}$ for each $j \in [1, l]$.
        \item The parties run $\VerifyConsistency{x_1, \ldots, x_l}$.
		If a party receives $false$ it outputs $\bot$.
       Otherwise, it outputs $\vec{X} = \{x_1, \ldots, x_l\}$.
    \end{enumerate}
\end{protocol}
