\section{Bit Share Conversion}

This section describes conversion of values stored in the boolean bit ABB from and to Yao-shared values. This method would enable designers to be able to use the best of both Yao based circuit evaluation and secret-sharing based circuit evaluation to optimize implementations without any compromises to security guarantees. As done for the input bits, the conversion uses commitment schemes for malicious security. The conversion protocol is derived from \cite{CCS:MohRin18}. 

The high level idea of the conversion from boolean bit ABB to Yao sharing is that the RSS shared input can be split into three components ($x_1, x_2, x_3$), of which each is known to two distinct parties. So, the parties can then Yao share each of these three components. Then if $f(x)$ was the original circuit to be evaluated, now $f'(x_1, x_2, x_3) = f(x_1 \oplus x_2 \oplus x_3)$ can be evaluated. The setup phase for $f'$ is assumed to be completed. In the description, we assume that the $i$-th bit of $f$, or the $i$, $i+1$, $i+2$-th bit of $f'$ is being converted.

\begin{protocol}[Bit Share Conversion]
	$\BittoYao{\bit{x}}{i}{crs}{\vec{e} \footnote{The encoding vector is known to garblers only, and is obtained during the setup phase.}}$:\\
	\indent \textcolor{blue}{\textit{$P_1$ does the following:}} \\
	\indent Set $x_1 = \bit{x}.s$ and $x_3 = \bit{x}.t$ \\
	\indent Set $C_2^0, \sigma_2^0 = \mathsf{Commit}_{crs}(\vec{e}_{i+1})$ \\
	\indent Set $C_2^1, \sigma_2^1 = \mathsf{Commit}_{crs}(\vec{e}_{i+1} \oplus \Delta)$ \\
	\indent Set $C_3^0, \sigma_3^0 = \mathsf{Commit}_{crs}(\vec{e}_{i+2})$ \\
	\indent Set $C_3^1, \sigma_3^1 = \mathsf{Commit}_{crs}(\vec{e}_{i+2} \oplus \Delta)$ \\
	\indent Set $h_2 = H(C_2^0, C_2^1)$ \\
	\indent Set $l_1 = \vec{e}_{i} \oplus x_1 \cdot \Delta$ \\
	\indent Send $l_1, C_3^0, C_3^1, \sigma_3^{x_3}, h_2$ to $P_3$ \\
	
	\indent \textcolor{blue}{\textit{$P_2$ does the following:}} \\
	\indent $P_2$ sets $x_2 = \bit{x}.s$ and $x_1 = \bit{x}.t$ \\
	\indent Set $x_1 = \bit{x}.s$ and $x_3 = \bit{x}.t$ \\
	\indent Set $C_2^0, \sigma_2^0 = \mathsf{Commit}_{crs}(\vec{e}_{i+1})$ \\
	\indent Set $C_2^1, \sigma_2^1 = \mathsf{Commit}_{crs}(\vec{e}_{i+1} \oplus \Delta)$ \\
	\indent Set $C_3^0, \sigma_3^0 = \mathsf{Commit}_{crs}(\vec{e}_{i+2})$ \\
	\indent Set $C_3^1, \sigma_3^1 = \mathsf{Commit}_{crs}(\vec{e}_{i+2} \oplus \Delta)$ \\
	\indent Set $h_3 = H(C_3^0, C_3^1)$ \\
	\indent Set $l_1 = \vec{e}_{i} \oplus x_1 \cdot \Delta$ \\
	\indent Send $l_1, C_2^0, C_2^1, \sigma_2^{x_2}, h_3$ to $P_3$ \\
	
	\indent \textcolor{blue}{\textit{$P_3$ does the following:}} \\
	\indent $P_3$ sets $x_3 = \bit{x}.s$ and $x_2 = \bit{x}.t$ \\
	\indent Check if the following hold, if not abort:
	\begin{itemize}[leftmargin=40pt] 
		\item $l_1$ sent by $P_1$ and $P_2$ are the same
		\item $h_3 = H(C_3^0, C_3^1)$
		\item $h_2 = H(C_2^0, C_2^1)$
		\item $\mathsf{Verify}_{crs}(C_2^{x_2}, \sigma_2^{x_2}) = 1$
		\item $\mathsf{Verify}_{crs}(C_3^{x_3}, \sigma_3^{x_3}) = 1$
	\end{itemize}
	\indent \indent return $l_1, \sigma_2^{x_2}.msg, \sigma_3^{x_3}.msg$ \\
	
	\noindent	
	$\YaotoBit{(W^0_i, \Delta)}{(W^x_i)}$\footnote{The first paranthesis corresponds to the garblers' input and the second one corresponds to the evaluator's input}:\\
	\indent $P_1$ and $P_3$ sample $y \gets_r \{0,1\}$ and $W_r^y \gets_r \{0,1\}^k$ \\
	\indent $P_1$ sends $W_r^0 := W_r^y \oplus (y \cdot \Delta)$ to $P_2$\\
	\indent \textcolor{blue}{\textit{$P_1$ and $P_2$ do the following:}} \\
	\indent $p = \mathsf{lsb}(W^0_i)$ \\
	\indent $W^0_z = W^0_x \oplus W_r^0$ \\
	\indent $W^1_z = W^0_x \oplus W_r^0 \oplus \Delta$ \\
	\indent $C_0= \mathsf{Commit}_{crs}(W^0_z)$ \\
	\indent $C_1= \mathsf{Commit}_{crs}(W^1_z)$ \\
	\indent Send $C_0, C_1$ to $P_3$ \\
	\indent $P_3$ sends $W_z^x := W^x_i \oplus W_r^y$ to $P_2$\\
	\indent $P_2$ checks if $W_z^x \in := \{W^0_z, W^1_z\}$ and sets $p_z = \mathsf{lsb}(W_z^x)$. If not abort.\\
	\indent \textcolor{blue}{\textit{$P_3$ does the following:}} \\
	\indent $p_x = \mathsf{lsb}(W_i^x)$ \\
	\indent Check if $\mathsf{Verify}_{crs}(C_{p_x \oplus y}, W^{x \oplus y}_z) = 1$. If not abort. \\
	\indent Check if $C_0, C_1$ sent from $P_1$ and $P_2$ are the same. If not abort. \\
	\indent $P_1$ sets $\bit{x}.t = p \oplus y$ and $\bit{x}.s = p$ \\
	\indent $P_2$ sets $\bit{x}.t = p_z$ and $\bit{x}.s = p_z \oplus p$ \\
	\indent $P_3$ sets $\bit{x}.t = p_x$ and $\bit{x}.s = y$ \\
	\indent All three parties output $\bit{x}$
	
\end{protocol}
