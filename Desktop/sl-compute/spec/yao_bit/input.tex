\section{Input}

This operation enables a party to generate Yao-shares from its input. We adopt the approach outlined in \cite{CCS:MohRosZha15}. Although the original work does not explicitly define this as a standalone input operation, we extract it from the broader protocol. The protocol assumes that the garbling has already been done, and the garblers possess their share (the false input wire label and the global offset $\Delta$). Additionally, the protocol uses the input encoding $\vec{e}$ obtained during Setup, as described in \ref{sec:yaobit:setup}. The protocol outputs the evaluator's share, which is the label corresponding to the party's input.

The protocol employs a commitment scheme, relying on the operations \textsf{Commit} and \textsf{Verify}. It assumes the availability of a publicly known common reference string ($crs$) used to instantiate the commitment scheme, as well as a shared key among the garblers for garbling and randomness extraction.

The behavior of the protocol depends on the role of each party and which party is providing the input. Therefore, the protocol also takes the identifier $id$ of the input-providing party as input. In the description below, we assume that $P_1$ and $P_2$ act as garblers, $P_3$ as the evaluator, and $P_{id}$ as the party supplying the $i$-th input of the circuit. For each of the evaluator's input bits, the circuit models it using two separate gates (with ids $i$ and $i+1$), and the actual input is represented as the XOR of their outputs. This design allows the evaluator to secret-share its input between the garblers while preserving input privacy.

\begin{protocol}[Input]	
	$\InputYao{x}{i}$:\\
	\indent $P_1$ and $P_2$ send $W_i := \vec{e}_{i} \oplus x \cdot \Delta$ to $P_3$. \\
	\indent $P_3$ checks if $W_i$ received from $P_1$ and $P_2$ are equal. If not aborts. \\
	\indent $P_3$ returns $W_i$. \\
	
	\noindent
	$\InputYaoFrom{x}{i}{P_{id}}$:\\
	\indent  if $id$ = 3: \\
	\indent \indent \textcolor{blue}{\textit{$P_3$ does the following:}} \\
	\indent \indent $x_1 \gets_r \{0,1\}$ \\
	\indent \indent $x_2 = x \oplus x_1$ \\
	\indent \indent Send $x_1$ to $P_1$ and $x_2$ to $P_2$ \\
	\indent \indent \textcolor{blue}{\textit{$P_1$ and $P_2$ do the following:}} \\
	\indent \indent for $j \in \{0,1\}$: \\
	\indent \indent \indent $(C^j_i, \sigma^j_i) = \mathsf{Commit}_{crs}(\vec{e}_i \oplus j \cdot \Delta)$\\
	\indent \indent \indent $(C^j_{i+1}, \sigma^j_{i+1}) = \mathsf{Commit}_{crs}(\vec{e}_{i+1} \oplus j \cdot \Delta)$\\
	\indent \indent \indent Send $C^j_i, C^j_{i+1}$ to $P_3$\\
	\indent \indent $P_1$ and $P_2$ send decommitments $\sigma^{x_1}_i$ and $\sigma^{x_2}_{i+1}$ respectively to $P_3$ \\
	\indent \indent \textcolor{blue}{\textit{$P_3$ does the following:}} \\
	\indent \indent Check for the following. If not true, then abort:
	\begin{itemize}[leftmargin=55pt] 
		\item \indent \indent \indent All commitments received from $P_1$ and $P_2$ are equal.
		\item \indent \indent \indent \textsf{Verify}$_{crs}(C^{x_1}_i, \sigma^{x_1}_i) = 1$
		\item \indent \indent \indent \textsf{Verify}$_{crs}(C^{x_2}_{i+1}, \sigma^{x_2}_{i+1}) = 1$
	\end{itemize}
	\indent \indent \indent return $\sigma^{x_1}_i.msg \footnote{Assuming each of these decommitments contain the original message, $.msg$ refers to this part.}, \sigma^{x_2}_{i+1}.msg$
	
	\indent  else: \\
	\indent \indent \textcolor{blue}{\textit{$P_1$ and $P_2$ do the following:}} \\
	\indent \indent $b \gets_r \{0,1\}$ \\
	\indent \indent for $j \in \{0,1\}$: \\
	\indent \indent \indent $(C^j_i, \sigma^j_i) = \mathsf{Commit}_{crs}(\vec{e}_i \oplus (j \oplus b) \cdot \Delta)$\\
	\indent \indent \indent Send $b, C^j_i$ to $P_3$\\
	\indent \indent $P_{id}$ sends decommitments $\sigma^{x \oplus b}_i$ to $P_3$ \\
	\indent \indent \textcolor{blue}{\textit{$P_3$ does the following:}} \\
	\indent \indent Check for the following. If not true, then abort:
	\begin{itemize}[leftmargin=55pt] 
		\item \indent \indent \indent All commitments received from $P_1$ and $P_2$ are equal.
		\item \indent \indent \indent \textsf{Verify}$_{crs}(C^{0}_i, \sigma^{x \oplus b}_i) \vee \mathsf{Verify}_{crs}(C^{1}_i, \sigma^{x \oplus b}_i) = 1$
	\end{itemize}
	\indent \indent \indent return $\sigma^{x \oplus b}_i.msg$
\end{protocol}

\section{Output}

The output operation takes a Yao-share as input and reveals the corresponding value to all parties. The evaluator begins by sending the wire label it holds for each output bit to the garblers. The garblers then authenticate these labels using the known output wire labels and the global offset ($\Delta$). Using this information, each garbler determines the corresponding output bit and sends the result back to the evaluator. Finally, the evaluator verifies that the outputs received from both garblers are consistent and reconstructs the final output. The garblers use the decoding information $\vec{d}$ obtained during Setup, as described in \ref{sec:yaobit:setup}.

\begin{protocol}[Output]	
	$\OutputYao{\yao{x}}$\footnote{The first paranthesis input represents values held by the garblers and the second paranthesis input represents values held by the evaluator}:\\
	\indent $P_3$ sends $\yao{x}.W^x_i$ to $P_1$ and $P_2$. \\
	\indent \textcolor{blue}{\textit{$P_1$ and $P_2$ do the following:}} \\
	\indent Check if one of the below holds true. If not, they abort:
	\begin{itemize}[leftmargin=40pt] 
		\item $\yao{x}.W^0_i = W^x_i$
		\item $\yao{x}.W^0_i \oplus \yao{x}.\Delta = W^x_i$
	\end{itemize}
	\indent \indent $x = \vec{d_i} \oplus \mathsf{lsb}(W^x_i)$ \\
	\indent Send $x$ to $P_3$. \\
	\indent return $x$ \\
	\indent $P_3$ checks if $x$ received by $P_1$ and $P_2$ are the same. \\
	\indent $P_3$ returns $x$ \\
	
	\noindent 
	$\OutputYaoTo{\yao{x}}{P_{id}}$:\\
	\indent if $id = 3$: \\
	\indent \indent $P_1$ and $P_2$ send $\vec{d}_{i}$ to $P_3$. \\
	\indent \indent $P_3$ checks if $\vec{d}_i$ received from $P_1$ and $P_2$ are equal. If not aborts. \\
	\indent \indent $P_3$ returns $x := \vec{d}_i \oplus \mathsf{lsb}(\yao{x}.W^x_i)$. \\
	\indent else: \\
	\indent \indent $P_3$ sends $\yao{x}.W^x_i$ to $P_{id}$. \\
	\indent \indent $P_{id}$ checks if one of the below holds true. If not, it aborts:
	\begin{itemize}[leftmargin=55pt] 
		\item $\yao{x}.W^0_i = W^x_i$
		\item $\yao{x}.W^0_i \oplus \yao{x}.\Delta = W^x_i$
	\end{itemize}
	\indent \indent \indent $x = \vec{d_i} \oplus \mathsf{lsb}(W^x_i)$ \\
	\indent \indent return $x$
\end{protocol}
