\section{Introduction}

We now describe an alternate mechanism for securely evaluating Boolean circuits, based on the seminal work of Yao \cite{FOCS:Yao82b}.
This method, commonly referred to as \textbf{Yao's Garbled Circuits}, offers a round-efficient alternative to the previously described
Boolean bit ABB functionality (Chapter~\ref{chap:bool-bit}), at the cost of increased communication complexity during the setup phase.
Specifically, the number of communication rounds in this approach is constant and independent of the circuit size, whereas in the
previous method, the number of rounds scales with the multiplicative depth of the circuit.

In this protocol, the participating parties assume one of two roles: the \textbf{garbler} and the \textbf{evaluator}. The role of the
garbler is to construct an encrypted (or "garbled'') version of the Boolean circuit, where each gate’s truth table is encrypted in such
a way that only valid combinations of input labels reveal the correct output label. The garbler also assigns random cryptographic labels
to all wire values in the circuit, effectively hiding the semantics of 0 and 1. These labels are then used to encode the parties' inputs.
Importantly, the garbler never learns which output labels the evaluator ultimately obtains and the input label which the evaluator
chooses, preserving input and output privacy.

The role of the evaluator is to evaluate the garbled circuit using encrypted inputs provided by the garbler. The evaluator uses these
inputs to traverse the garbled circuit gate-by-gate, decrypting exactly one entry per gate to learn the corresponding output label,
until the final output label is obtained. Importantly, the garbler never learns which output labels the evaluator ultimately obtains and 
the input label which the evaluator chooses, preserving input and output privacy.

Importantly, the garbler's operations can be carried out entirely prior to knowing the actual inputs, making this part of the protocol
suitable for a \textbf{setup phase}. In contrast, the evaluator’s computation constitutes the \textbf{online phase}, as it requires
knowledge of both parties’ inputs (in encrypted form) to evaluate the circuit.

To instantiate our protocols, we adopt the half-gates technique introduced in \cite{EC:ZahRosEva15}, which enables efficient garbling of
AND gates with minimal overhead. However, this technique is secure only in the semi-honest setting. To achieve security against
malicious adversaries in the three-party honest-majority setting, we leverage the compiler based on dual-execution paradigm introduced
in \cite{CCS:MohRosZha15}. Their approach enables the instantiation of two garblers instead of one, such that each independently
constructs a garbled circuit.

This duplication allows us to detect any malicious behavior by comparing the garbled circuits generated by the two garblers. Assuming at
least one of them is honest, the evaluator can detect inconsistencies and reject malformed circuits. Equality checks on the garblers'
messages ensure that deviations by a corrupted garbler are caught. 

To ensure honest behavior by the evaluator, they use the garbled outputs to play the part of a message authentication code, allowing the
garblers to verify that the evaluator’s output is consistent with a correct evaluation of the garbled circuit. The full details of this
approach will be described in the later sections.

The Yao bit functionality is described below. More detailed descriptions, as well as the protocols implementing each of these
functionalities, will be presented in later sections. We defer all proofs to the original papers for brevity.



\begin{functionality}
	
	\SetupYao{1^k}{f}: Initialize the ABB with the security parameter $k$ and the circuit $f$ as input. \\
	
	\InputYao{x}{i}:  Given a public bit $x$ as the $i$-th input of the circuit, store it in the ABB and return a public identifier to the variable. \\
	
	\InputYaoFrom{x}{i}{P_{id}}:  Given a private bit $x$ as the $i$-th input of the circuit, held by $P_{id}$, store it in the ABB and return a public identifier to the variable. \\
	
	\OutputYao{\yao{x}}: Given a bit stored in the ABB under identifier $x$,
	reveal it to all parties. \\
	
	\OutputYaoTo{\yao{x}}{P_{id}}: Given a bit stored in the ABB under identifier $x$,
	reveal it to $P_{id}$. \\
	
	\EvaluateCircuitYao{\yao{\vec{X}}}: Given a vector of bits stored in the ABB, evaluate $f$ on the input, store the outputs in the ABB and return a vector of public identifiers for the outputs.
	
\end{functionality}
